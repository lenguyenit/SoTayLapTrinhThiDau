<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPH - Chương 20: Luồng và lát cắt</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 { margin-top: 40px; }
        p { margin-bottom: 15px; text-align: justify; }
        
        /* Code styling */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f1f3f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d63384;
        }
        
        /* Syntax highlighting */
        .cpp-keyword { color: #0000ff; font-weight: bold; }
        .cpp-type { color: #2b91af; }
        .cpp-number { color: #098658; }
        .cpp-func { color: #795e26; }
        .cpp-comment { color: #008000; font-style: italic; }

        /* Graphics Containers */
        .graphic-box {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        /* SVG Styling */
        svg text { font-family: "Segoe UI", sans-serif; font-size: 14px; text-anchor: middle; dominant-baseline: central; font-weight: bold; }
        .node-circle { fill: #fff; stroke: #2c3e50; stroke-width: 2; }
        .node-source { fill: #e8f5e9; stroke: #2e7d32; stroke-width: 2; } /* Nguồn - Xanh lá */
        .node-sink { fill: #ffebee; stroke: #c62828; stroke-width: 2; } /* Đích - Đỏ */
        .edge-line { stroke: #555; stroke-width: 2; }
        .edge-flow { stroke: #2980b9; stroke-width: 3; } /* Cạnh có luồng */
        .edge-residual { stroke: #e67e22; stroke-width: 2; stroke-dasharray: 4; } /* Cạnh thặng dư */
        .arrow-head { fill: #555; }
        .label-bg { fill: white; opacity: 0.9; }

        /* TOC */
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc a { text-decoration: none; color: #007bff; font-weight: 500; }
    </style>
</head>
<body>

    <div class="toc">
        <h3>Mục lục - Chương 20</h3>
        <ul>
            <li><a href="#intro">Luồng và lát cắt</a></li>
            <li><a href="#sec20.1">20.1 Thuật toán Ford-Fulkerson</a></li>
            <li><a href="#sec20.2">20.2 Đường đi không giao nhau</a></li>
            <li><a href="#sec20.3">20.3 Cặp ghép cực đại</a></li>
            <li><a href="#sec20.4">20.4 Phủ đường đi</a></li>
        </ul>
    </div>

    <h1 id="intro">Chương 20: Luồng và lát cắt (Flows and cuts)</h1>
    <p>
        Trong chương này, chúng ta sẽ tìm hiểu về một tập hợp các bài toán liên quan đến luồng qua mạng lưới và cắt mạng lưới.
    </p>
    <p>
        Trong bài toán <strong>luồng cực đại</strong> (maximum flow), nhiệm vụ của chúng ta là gửi càng nhiều luồng (flow) càng tốt từ nút nguồn (source) đến nút đích (sink) trong một đồ thị có hướng và có trọng số. Trọng số của mỗi cạnh biểu thị <strong>dung lượng</strong> (capacity) của nó - lượng luồng tối đa có thể đi qua cạnh đó.
    </p>
    <p>
        Bài toán <strong>lát cắt nhỏ nhất</strong> (minimum cut) liên quan chặt chẽ đến bài toán luồng cực đại. Nhiệm vụ là loại bỏ một tập hợp các cạnh có tổng trọng số nhỏ nhất sao cho không còn đường đi nào từ nguồn đến đích.
    </p>

    <div class="graphic-box">
        <svg width="400" height="200" viewBox="0 0 400 200">
            <defs>
                <marker id="arrowFlow" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                    <path d="M0,0 L0,6 L9,3 z" fill="#555" />
                </marker>
            </defs>

            <g id="flow-edges">
                <line x1="50" y1="100" x2="150" y2="50" class="edge-line" marker-end="url(#arrowFlow)"/> <line x1="50" y1="100" x2="150" y2="150" class="edge-line" marker-end="url(#arrowFlow)"/> <line x1="150" y1="50" x2="250" y2="50" class="edge-line" marker-end="url(#arrowFlow)"/> <line x1="150" y1="150" x2="250" y2="150" class="edge-line" marker-end="url(#arrowFlow)"/> <line x1="150" y1="50" x2="150" y2="150" class="edge-line" marker-end="url(#arrowFlow)"/> <line x1="250" y1="50" x2="350" y2="100" class="edge-line" marker-end="url(#arrowFlow)"/> <line x1="250" y1="150" x2="350" y2="100" class="edge-line" marker-end="url(#arrowFlow)"/> <rect x="90" y="65" width="20" height="15" class="label-bg" transform="translate(-10,-10)"/> <text x="90" y="65" font-size="12">5</text>
                <rect x="90" y="135" width="20" height="15" class="label-bg" transform="translate(-10,-10)"/> <text x="90" y="135" font-size="12">6</text>
                <rect x="200" y="40" width="20" height="15" class="label-bg" transform="translate(-10,-10)"/> <text x="200" y="40" font-size="12">4</text>
                <rect x="200" y="160" width="20" height="15" class="label-bg" transform="translate(-10,-10)"/> <text x="200" y="160" font-size="12">8</text>
                <rect x="300" y="65" width="20" height="15" class="label-bg" transform="translate(-10,-10)"/> <text x="300" y="65" font-size="12">5</text>
                <rect x="300" y="135" width="20" height="15" class="label-bg" transform="translate(-10,-10)"/> <text x="300" y="135" font-size="12">4</text>
            </g>

            <g id="flow-nodes">
                <circle cx="50" cy="100" r="18" class="node-source"/> <text x="50" y="100">1</text>
                <circle cx="150" cy="50" r="18" class="node-circle"/> <text x="150" y="50">2</text>
                <circle cx="250" cy="50" r="18" class="node-circle"/> <text x="250" y="50">3</text>
                <circle cx="150" cy="150" r="18" class="node-circle"/> <text x="150" y="150">4</text>
                <circle cx="250" cy="150" r="18" class="node-circle"/> <text x="250" y="150">5</text>
                <circle cx="350" cy="100" r="18" class="node-sink"/> <text x="350" y="100">6</text>
            </g>
            <text x="200" y="190" font-size="13" fill="#666">Nút 1 là Nguồn (Source), Nút 6 là Đích (Sink)</text>
        </svg>
    </div>

    <h2 id="sec20.1">20.1 Thuật toán Ford-Fulkerson</h2>
    <p>
        Thuật toán Ford-Fulkerson tìm luồng cực đại trong đồ thị. Thuật toán hoạt động bằng cách lặp đi lặp lại việc tìm một <strong>đường tăng luồng</strong> (augmenting path) từ nguồn đến đích và thêm luồng vào đường đó.
    </p>
    <p>
        <strong>Định lý luồng cực đại lát cắt nhỏ nhất (Max-flow min-cut theorem):</strong> Giá trị của luồng cực đại bằng dung lượng của lát cắt nhỏ nhất.
    </p>
    <p>
        Trong cài đặt thực tế, chúng ta thường sử dụng phiên bản <strong>Edmonds-Karp</strong>, sử dụng BFS để tìm đường tăng luồng ngắn nhất (về số cạnh).
    </p>

    <h3>Cài đặt (Edmonds-Karp)</h3>
    <p>
        Mảng <code>capacity[u][v]</code> lưu dung lượng còn lại của cạnh từ \(u\) đến \(v\). Đồ thị này cũng chứa các <strong>cạnh ngược</strong> (dung lượng ban đầu bằng 0) để cho phép thuật toán "hủy" luồng đã gửi.
    </p>

<pre><code><span class="cpp-type">long</span> <span class="cpp-type">long</span> capacity[N][N];
<span class="cpp-type">vector</span>&lt;<span class="cpp-keyword">int</span>&gt; adj[N];
<span class="cpp-keyword">int</span> parent[N];

<span class="cpp-keyword">int</span> <span class="cpp-func">bfs</span>(<span class="cpp-keyword">int</span> s, <span class="cpp-keyword">int</span> t) {
    fill(parent, parent + N, <span class="cpp-number">-1</span>);
    parent[s] = <span class="cpp-number">-2</span>;
    <span class="cpp-type">queue</span>&lt;<span class="cpp-type">pair</span>&lt;<span class="cpp-keyword">int</span>, <span class="cpp-keyword">int</span>&gt;&gt; q;
    q.push({s, INF});

    <span class="cpp-keyword">while</span> (!q.empty()) {
        <span class="cpp-keyword">int</span> cur = q.front().first;
        <span class="cpp-keyword">int</span> flow = q.front().second;
        q.pop();

        <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> next : adj[cur]) {
            <span class="cpp-keyword">if</span> (parent[next] == <span class="cpp-number">-1</span> && capacity[cur][next] &gt; <span class="cpp-number">0</span>) {
                parent[next] = cur;
                <span class="cpp-keyword">int</span> new_flow = min(flow, (<span class="cpp-keyword">int</span>)capacity[cur][next]);
                <span class="cpp-keyword">if</span> (next == t)
                    <span class="cpp-keyword">return</span> new_flow;
                q.push({next, new_flow});
            }
        }
    }
    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}

<span class="cpp-type">long</span> <span class="cpp-type">long</span> <span class="cpp-func">max_flow</span>(<span class="cpp-keyword">int</span> s, <span class="cpp-keyword">int</span> t) {
    <span class="cpp-type">long</span> <span class="cpp-type">long</span> flow = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">int</span> new_flow;

    <span class="cpp-keyword">while</span> (new_flow = <span class="cpp-func">bfs</span>(s, t)) {
        flow += new_flow;
        <span class="cpp-keyword">int</span> cur = t;
        <span class="cpp-keyword">while</span> (cur != s) {
            <span class="cpp-keyword">int</span> prev = parent[cur];
            capacity[prev][cur] -= new_flow; <span class="cpp-comment">// Giảm dung lượng cạnh thuận</span>
            capacity[cur][prev] += new_flow; <span class="cpp-comment">// Tăng dung lượng cạnh ngược</span>
            cur = prev;
        }
    }
    <span class="cpp-keyword">return</span> flow;
}</code></pre>

    <h2 id="sec20.2">20.2 Đường đi không giao nhau (Disjoint paths)</h2>
    <p>
        Bài toán luồng cực đại có thể được sử dụng để tìm số lượng đường đi không giao nhau tối đa từ nút nguồn đến nút đích.
    </p>

    <h3>1. Đường đi không giao nhau về cạnh</h3>
    <p>
        Đơn giản là gán dung lượng 1 cho mọi cạnh. Kết quả <code>max_flow(s, t)</code> chính là số lượng đường đi không chia sẻ cạnh.
    </p>

    <h3>2. Đường đi không giao nhau về nút</h3>
    <p>
        Để đảm bảo mỗi nút chỉ được sử dụng một lần, ta sử dụng kỹ thuật <strong>tách nút</strong> (node splitting). Mỗi nút \(u\) được tách thành \(u_{in}\) và \(u_{out}\) với một cạnh nối \(u_{in} \to u_{out}\) có dung lượng 1.
    </p>

    <div class="graphic-box">
        <svg width="300" height="150" viewBox="0 0 300 150">
            <defs>
                <marker id="arrowSplit" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                    <path d="M0,0 L0,6 L9,3 z" fill="#555" />
                </marker>
            </defs>

            <g id="split-edges">
                <line x1="20" y1="75" x2="100" y2="75" class="edge-line" marker-end="url(#arrowSplit)"/>
                <line x1="100" y1="75" x2="200" y2="75" class="edge-line" marker-end="url(#arrowSplit)"/>
                <line x1="200" y1="75" x2="280" y2="75" class="edge-line" marker-end="url(#arrowSplit)"/>
                <text x="150" y="65" font-size="12" fill="#e67e22">Cap = 1</text>
            </g>

            <g id="split-nodes">
                <circle cx="100" cy="75" r="18" class="node-circle"/> <text x="100" y="75" font-size="12">u_in</text>
                <circle cx="200" cy="75" r="18" class="node-circle"/> <text x="200" y="75" font-size="12">u_out</text>
            </g>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 20.2: Tách nút để giới hạn dung lượng nút là 1</div>
    </div>

    <h3>Cài đặt Xây dựng Đồ thị Tách nút</h3>
    <p>
        Giả sử đồ thị có \(N\) nút. Ta ánh xạ: \(u_{in} = u\), \(u_{out} = u + N\).
    </p>

<pre><code><span class="cpp-comment">// Hàm thêm cạnh vào đồ thị luồng (tự động thêm cạnh ngược dung lượng 0)</span>
<span class="cpp-keyword">void</span> <span class="cpp-func">add_flow_edge</span>(<span class="cpp-keyword">int</span> u, <span class="cpp-keyword">int</span> v, <span class="cpp-keyword">int</span> cap) {
    adj[u].push_back(v);
    adj[v].push_back(u);
    capacity[u][v] = cap;
    capacity[v][u] = <span class="cpp-number">0</span>;
}

<span class="cpp-comment">// Xây dựng đồ thị</span>
<span class="cpp-keyword">void</span> <span class="cpp-func">build_node_disjoint_graph</span>(<span class="cpp-keyword">int</span> n, <span class="cpp-type">vector</span>&lt;<span class="cpp-type">pair</span>&lt;<span class="cpp-keyword">int</span>,<span class="cpp-keyword">int</span>&gt;&gt;& edges) {
    <span class="cpp-comment">// 1. Cạnh nội bộ u_in -> u_out</span>
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) {
        <span class="cpp-func">add_flow_edge</span>(i, i + n, <span class="cpp-number">1</span>); 
    }

    <span class="cpp-comment">// 2. Cạnh nối giữa các nút: u -> v chuyển thành u_out -> v_in</span>
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">auto</span> e : edges) {
        <span class="cpp-keyword">int</span> u = e.first;
        <span class="cpp-keyword">int</span> v = e.second;
        <span class="cpp-func">add_flow_edge</span>(u + n, v, INF); <span class="cpp-comment">// Dung lượng vô hạn giữa các nút</span>
    }
}
<span class="cpp-comment">// Kết quả: max_flow(source + n, sink)</span></code></pre>

    <h2 id="sec20.3">20.3 Cặp ghép cực đại (Maximum matchings)</h2>
    <p>
        Trong đồ thị hai phía, bài toán tìm cặp ghép cực đại có thể được giải bằng luồng cực đại. Tuy nhiên, thuật toán <strong>Kuhn (DFS)</strong> (còn gọi là Turbo Matching) thường gọn nhẹ và nhanh hơn cho bài toán này.
    </p>

    <div class="graphic-box">
        <svg width="400" height="200" viewBox="0 0 400 200">
            <g id="match-edges">
                <line x1="50" y1="100" x2="150" y2="50" class="edge-line" marker-end="url(#arrowFlow)"/>
                <line x1="50" y1="100" x2="150" y2="100" class="edge-line" marker-end="url(#arrowFlow)"/>
                <line x1="50" y1="100" x2="150" y2="150" class="edge-line" marker-end="url(#arrowFlow)"/>
                
                <line x1="150" y1="50" x2="250" y2="50" class="edge-flow"/>
                <line x1="150" y1="100" x2="250" y2="100" class="edge-line" stroke-dasharray="4"/>
                <line x1="150" y1="150" x2="250" y2="150" class="edge-flow"/>
                
                <line x1="250" y1="50" x2="350" y2="100" class="edge-line" marker-end="url(#arrowFlow)"/>
                <line x1="250" y1="100" x2="350" y2="100" class="edge-line" marker-end="url(#arrowFlow)"/>
                <line x1="250" y1="150" x2="350" y2="100" class="edge-line" marker-end="url(#arrowFlow)"/>
            </g>

            <g id="match-nodes">
                <circle cx="50" cy="100" r="18" class="node-source"/> <text x="50" y="100">S</text>
                <circle cx="150" cy="50" r="15" class="node-circle"/>
                <circle cx="150" cy="100" r="15" class="node-circle"/>
                <circle cx="150" cy="150" r="15" class="node-circle"/>
                <circle cx="250" cy="50" r="15" class="node-circle"/>
                <circle cx="250" cy="100" r="15" class="node-circle"/>
                <circle cx="250" cy="150" r="15" class="node-circle"/>
                <circle cx="350" cy="100" r="18" class="node-sink"/> <text x="350" y="100">T</text>
            </g>
        </svg>
    </div>

    <h3>Cài đặt Thuật toán Kuhn (DFS)</h3>
    <p>
        Thuật toán này tìm "đường mở" (augmenting path) để tăng số lượng cặp ghép.
    </p>

<pre><code><span class="cpp-type">vector</span>&lt;<span class="cpp-keyword">int</span>&gt; adj[N]; <span class="cpp-comment">// Chỉ cần lưu cạnh từ Trái -> Phải</span>
<span class="cpp-keyword">int</span> match[N];       <span class="cpp-comment">// match[v] = u (nút v bên phải ghép với u bên trái)</span>
<span class="cpp-keyword">bool</span> vis[N];        <span class="cpp-comment">// Đánh dấu đã thăm trong đợt DFS</span>

<span class="cpp-keyword">bool</span> <span class="cpp-func">dfs</span>(<span class="cpp-keyword">int</span> u) {
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> v : adj[u]) {
        <span class="cpp-keyword">if</span> (vis[v]) <span class="cpp-keyword">continue</span>;
        vis[v] = <span class="cpp-keyword">true</span>;
        
        <span class="cpp-comment">// Nếu v chưa ghép hoặc có thể tìm ghép mới cho match[v]</span>
        <span class="cpp-keyword">if</span> (match[v] &lt; <span class="cpp-number">0</span> || <span class="cpp-func">dfs</span>(match[v])) {
            match[v] = u;
            <span class="cpp-keyword">return</span> <span class="cpp-keyword">true</span>;
        }
    }
    <span class="cpp-keyword">return</span> <span class="cpp-keyword">false</span>;
}

<span class="cpp-comment">// Trong main:</span>
<span class="cpp-comment">// fill(match, match + N, -1);</span>
<span class="cpp-comment">// int result = 0;</span>
<span class="cpp-comment">// for (int i = 1; i <= n_left; i++) {</span>
<span class="cpp-comment">//     fill(vis, vis + N, false);</span>
<span class="cpp-comment">//     if (dfs(i)) result++;</span>
<span class="cpp-comment">// }</span></code></pre>

    <h2 id="sec20.4">20.4 Phủ đường đi (Path covers)</h2>
    <p>
        Một <strong>phủ đường đi</strong> của một đồ thị có hướng không chu trình (DAG) là một tập hợp các đường đi sao cho mỗi nút của đồ thị thuộc về chính xác một đường đi. Nhiệm vụ là tìm số lượng đường đi tối thiểu.
    </p>
    <p>
        Công thức:
        $$ \text{Số đường đi tối thiểu} = n - \text{Cặp ghép cực đại} $$
        Trong đó \(n\) là số nút của DAG, và cặp ghép cực đại được tính trên một đồ thị hai phía được xây dựng từ DAG.
    </p>

    <h3>Cài đặt</h3>
    <p>
        Chúng ta xây dựng đồ thị hai phía: với mỗi cạnh \(u \to v\) trong DAG, thêm cạnh từ \(u\) (bên trái) sang \(v\) (bên phải). Sau đó chạy thuật toán cặp ghép (Kuhn).
    </p>

<pre><code><span class="cpp-keyword">int</span> main() {
    <span class="cpp-keyword">int</span> n, m;
    cin &gt;&gt; n &gt;&gt; m;

    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">0</span>; i &lt; m; i++) {
        <span class="cpp-keyword">int</span> u, v;
        cin &gt;&gt; u &gt;&gt; v;
        <span class="cpp-comment">// Thêm cạnh vào đồ thị hai phía để tìm cặp ghép</span>
        adj[u].push_back(v); 
    }

    fill(match, match + N, <span class="cpp-number">-1</span>);
    <span class="cpp-keyword">int</span> max_matching = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) {
        fill(vis, vis + N, <span class="cpp-keyword">false</span>);
        <span class="cpp-keyword">if</span> (<span class="cpp-func">dfs</span>(i)) {
            max_matching++;
        }
    }

    <span class="cpp-type">cout</span> &lt;&lt; (n - max_matching) &lt;&lt; <span class="cpp-string">"\n"</span>;

    <span class="cpp-comment">// Phần mở rộng: In các đường đi (truy vết match[])</span>
    <span class="cpp-comment">// ... (Xem phần giải thích ở trên để tự cài đặt)</span>

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}</code></pre>

</body>
</html>