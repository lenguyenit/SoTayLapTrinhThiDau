<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPH - Chương 9: Truy vấn đoạn</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 { margin-top: 40px; }
        p { margin-bottom: 15px; text-align: justify; }
        
        /* Code styling */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f1f3f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d63384;
        }
        
        /* Syntax highlighting */
        .cpp-keyword { color: #0000ff; font-weight: bold; }
        .cpp-type { color: #2b91af; }
        .cpp-number { color: #098658; }
        .cpp-func { color: #795e26; }
        .cpp-comment { color: #008000; font-style: italic; }

        /* Graphics */
        .graphic-box {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow-x: auto;
        }
        svg text { font-family: "Segoe UI", sans-serif; font-size: 14px; }
        .array-cell { fill: #fff; stroke: #333; stroke-width: 1.5; }
        .tree-node { fill: #fff; stroke: #2c3e50; stroke-width: 2; }
        .highlight-rect { fill: rgba(52, 152, 219, 0.2); stroke: #3498db; stroke-width: 2; }
        .range-bar { fill: #3498db; opacity: 0.7; rx: 4; }
        .bit-bar { fill: #2ecc71; stroke: #27ae60; stroke-width: 1; }

        /* TOC */
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc a { text-decoration: none; color: #007bff; font-weight: 500; }
    </style>
</head>
<body>

    <div class="toc">
        <h3>Mục lục - Chương 9</h3>
        <ul>
            <li><a href="#intro">Truy vấn đoạn</a></li>
            <li><a href="#sec9.1">9.1 Truy vấn mảng tĩnh</a></li>
            <li><a href="#sec9.2">9.2 Cây chỉ số nhị phân (Binary Indexed Tree)</a></li>
            <li><a href="#sec9.3">9.3 Cây phân đoạn (Segment Tree)</a></li>
            <li><a href="#sec9.4">9.4 Các kỹ thuật bổ sung</a></li>
        </ul>
    </div>

    <h1 id="intro">Chương 9: Truy vấn đoạn (Range queries)</h1>
    <p>
        Trong chương này, chúng ta thảo luận về các cấu trúc dữ liệu cho phép xử lý hiệu quả các truy vấn đoạn. Trong một truy vấn đoạn, nhiệm vụ của chúng ta là tính toán một giá trị dựa trên một mảng con của một mảng. Các truy vấn đoạn điển hình là:
    </p>
    <ul>
        <li>\(sum_q(a,b)\): tính tổng các giá trị trong đoạn \([a, b]\)</li>
        <li>\(min_q(a,b)\): tìm giá trị nhỏ nhất trong đoạn \([a, b]\)</li>
        <li>\(max_q(a,b)\): tìm giá trị lớn nhất trong đoạn \([a, b]\)</li>
    </ul>
    <p>
        Ví dụ, xem xét đoạn \([3,6]\) trong mảng sau:
    </p>
    
    <div class="graphic-box">
        <svg width="400" height="80" viewBox="0 0 400 80">
            <g transform="translate(10, 30)">
                <text x="20" y="-10" text-anchor="middle" class="label-text">0</text>
                <rect x="0" y="0" width="40" height="40" class="array-cell"/> <text x="20" y="25" text-anchor="middle">1</text>
                
                <text x="60" y="-10" text-anchor="middle" class="label-text">1</text>
                <rect x="40" y="0" width="40" height="40" class="array-cell"/> <text x="60" y="25" text-anchor="middle">3</text>
                
                <text x="100" y="-10" text-anchor="middle" class="label-text">2</text>
                <rect x="80" y="0" width="40" height="40" class="array-cell"/> <text x="100" y="25" text-anchor="middle">8</text>
                
                <text x="140" y="-10" text-anchor="middle" class="label-text">3</text>
                <rect x="120" y="0" width="40" height="40" class="array-cell" style="fill:#e3f2fd"/> <text x="140" y="25" text-anchor="middle">4</text>
                
                <text x="180" y="-10" text-anchor="middle" class="label-text">4</text>
                <rect x="160" y="0" width="40" height="40" class="array-cell" style="fill:#e3f2fd"/> <text x="180" y="25" text-anchor="middle">6</text>
                
                <text x="220" y="-10" text-anchor="middle" class="label-text">5</text>
                <rect x="200" y="0" width="40" height="40" class="array-cell" style="fill:#e3f2fd"/> <text x="220" y="25" text-anchor="middle">1</text>
                
                <text x="260" y="-10" text-anchor="middle" class="label-text">6</text>
                <rect x="240" y="0" width="40" height="40" class="array-cell" style="fill:#e3f2fd"/> <text x="260" y="25" text-anchor="middle">3</text>
                
                <text x="300" y="-10" text-anchor="middle" class="label-text">7</text>
                <rect x="280" y="0" width="40" height="40" class="array-cell"/> <text x="300" y="25" text-anchor="middle">4</text>
                
                <path d="M120,45 L120,55 L280,55 L280,45" fill="none" stroke="#2196f3" stroke-width="2"/>
                <text x="200" y="70" text-anchor="middle" fill="#2196f3" font-weight="bold">Đoạn [3, 6]</text>
            </g>
        </svg>
    </div>

    <p>
        Trong trường hợp này, \(sum_q(3,6)=14\), \(min_q(3,6)=1\) và \(max_q(3,6)=6\).
    </p>
    <p>
        Một cách đơn giản để xử lý các truy vấn đoạn là sử dụng vòng lặp đi qua tất cả các giá trị mảng trong đoạn. Ví dụ, hàm sau có thể được sử dụng để xử lý truy vấn tổng:
    </p>

<pre><code><span class="cpp-keyword">int</span> <span class="cpp-func">sum</span>(<span class="cpp-keyword">int</span> a, <span class="cpp-keyword">int</span> b) {
    <span class="cpp-keyword">int</span> s = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = a; i &lt;= b; i++) {
        s += array[i];
    }
    <span class="cpp-keyword">return</span> s;
}</code></pre>

    <p>
        Hàm này hoạt động trong thời gian \(O(n)\), trong đó \(n\) là kích thước của mảng. Do đó, chúng ta có thể xử lý \(q\) truy vấn trong thời gian \(O(nq)\). Tuy nhiên, nếu cả \(n\) và \(q\) đều lớn, cách tiếp cận này sẽ chậm. May mắn thay, có nhiều cách để xử lý truy vấn đoạn hiệu quả hơn nhiều.
    </p>

    <h2 id="sec9.1">9.1 Truy vấn mảng tĩnh (Static array queries)</h2>
    <p>
        Đầu tiên chúng ta tập trung vào tình huống mảng là tĩnh, tức là các giá trị mảng không bao giờ được cập nhật giữa các truy vấn. Trong trường hợp này, chỉ cần xây dựng một cấu trúc dữ liệu tĩnh cho biết câu trả lời cho bất kỳ truy vấn nào.
    </p>

    <h3>Truy vấn tổng (Sum queries)</h3>
    <p>
        Chúng ta có thể dễ dàng xử lý các truy vấn tổng trên một mảng tĩnh bằng cách xây dựng một mảng tổng tiền tố (prefix sum array). Mỗi giá trị trong mảng tổng tiền tố bằng tổng các giá trị trong mảng gốc tính đến vị trí đó, tức là giá trị tại vị trí \(k\) là \(sum_q(0,k)\). Mảng tổng tiền tố có thể được xây dựng trong thời gian \(O(n)\).
    </p>
    <p>
        Vì mảng tổng tiền tố chứa tất cả các giá trị của \(sum_q(0,k)\), chúng ta có thể tính toán bất kỳ giá trị nào của \(sum_q(a,b)\) trong thời gian \(O(1)\) như sau:
        $$ sum_q(a,b) = sum_q(0,b) - sum_q(0,a-1) $$
        Bằng cách định nghĩa \(sum_q(0,-1)=0\), công thức trên cũng đúng khi \(a=0\).
    </p>
    <p>
        Ví dụ, \(sum_q(3,6) = sum_q(0,6) - sum_q(0,2) = 27 - 8 = 19\).
    </p>
    <p>
        Cũng có thể tổng quát hóa ý tưởng này cho các chiều cao hơn. Ví dụ, chúng ta có thể xây dựng một mảng tổng tiền tố hai chiều có thể được sử dụng để tính tổng của bất kỳ mảng con hình chữ nhật nào trong thời gian \(O(1)\). Mỗi tổng trong mảng như vậy tương ứng với một mảng con bắt đầu từ góc trên bên trái của mảng.
    </p>

    <div class="graphic-box">
        <svg width="300" height="200" viewBox="0 0 300 200">
            <rect x="20" y="20" width="260" height="160" fill="#fff" stroke="#333" stroke-width="2"/>
            
            <rect x="20" y="20" width="200" height="120" fill="none" stroke="#999" stroke-dasharray="4"/>
            <text x="230" y="150" text-anchor="middle" font-weight="bold">D</text>
            
            <rect x="20" y="20" width="80" height="120" fill="#e0e0e0" opacity="0.5"/>
            <text x="90" y="150" text-anchor="middle">C</text>
            
            <rect x="20" y="20" width="200" height="50" fill="#e0e0e0" opacity="0.5"/>
            <text x="230" y="60" text-anchor="middle">B</text>
            
            <rect x="20" y="20" width="80" height="50" fill="#bdbdbd"/>
            <text x="90" y="60" text-anchor="middle">A</text>
            
            <rect x="100" y="70" width="120" height="70" fill="none" stroke="#2c3e50" stroke-width="2" />
            <text x="160" y="110" text-anchor="middle" font-weight="bold" fill="#2c3e50">Hình chữ nhật cần tính</text>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 9.1: Công thức bao hàm - loại trừ trên mảng 2D</div>
    </div>

    <p>
        Tổng của mảng con màu xám có thể được tính bằng công thức:
        $$ S(D) - S(B) - S(C) + S(A) $$
        trong đó \(S(X)\) ký hiệu tổng các giá trị trong mảng con hình chữ nhật từ góc trên bên trái đến vị trí của \(X\).
    </p>

    <h3>Truy vấn giá trị nhỏ nhất (Minimum queries)</h3>
    <p>
        Truy vấn giá trị nhỏ nhất khó xử lý hơn truy vấn tổng. Tuy nhiên, vẫn có một phương pháp tiền xử lý khá đơn giản trong thời gian \(O(n \log n)\) để sau đó chúng ta có thể trả lời bất kỳ truy vấn giá trị nhỏ nhất nào trong thời gian \(O(1)\). Phương pháp này thường được gọi là bảng thưa (sparse table).
    </p>
    <p>
        Ý tưởng là tính trước tất cả các giá trị \(min_q(a,b)\) trong đó độ dài của đoạn \(b-a+1\) là một lũy thừa của hai. Số lượng giá trị tính trước là \(O(n \log n)\). Các giá trị này có thể được tính toán hiệu quả bằng công thức truy hồi:
        $$ min_q(a, b) = \min(min_q(a, a+w-1), min_q(a+w, b)) $$
        trong đó \(b-a+1\) là lũy thừa của hai và \(w = (b-a+1)/2\).
    </p>
    <p>
        Sau đó, bất kỳ giá trị nào của \(min_q(a,b)\) đều có thể được tính toán trong thời gian \(O(1)\) là giá trị nhỏ nhất của hai giá trị đã tính trước (có thể chồng lên nhau). Gọi \(k\) là lũy thừa lớn nhất của hai không vượt quá \(b-a+1\). Chúng ta có thể tính:
        $$ min_q(a,b) = \min(min_q(a, a+k-1), min_q(b-k+1, b)) $$
    </p>
    
    <div class="graphic-box">
        <svg width="400" height="120" viewBox="0 0 400 120">
            <rect x="50" y="20" width="300" height="30" fill="none" stroke="#333" stroke-width="2"/>
            <text x="200" y="40" text-anchor="middle">Đoạn [a, b]</text>
            <text x="50" y="15" text-anchor="middle">a</text>
            <text x="350" y="15" text-anchor="middle">b</text>
            
            <rect x="50" y="60" width="200" height="10" class="range-bar" fill="#e74c3c"/>
            <text x="150" y="85" text-anchor="middle" fill="#e74c3c" font-size="12">Đoạn 1 (độ dài k)</text>
            
            <rect x="150" y="90" width="200" height="10" class="range-bar" fill="#3498db"/>
            <text x="250" y="115" text-anchor="middle" fill="#3498db" font-size="12">Đoạn 2 (độ dài k)</text>
            
            <line x1="50" y1="60" x2="50" y2="50" stroke="#999" stroke-dasharray="2"/>
            <line x1="350" y1="90" x2="350" y2="50" stroke="#999" stroke-dasharray="2"/>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 9.2: Hai đoạn độ dài \(k\) phủ kín đoạn \([a,b]\)</div>
    </div>

    <h2 id="sec9.2">9.2 Cây chỉ số nhị phân (Binary Indexed Tree)</h2>
    <p>
        Một cây chỉ số nhị phân (Binary Indexed Tree) hay cây Fenwick có thể được xem như một biến thể động của mảng tổng tiền tố. Nó hỗ trợ hai thao tác trong thời gian \(O(\log n)\): xử lý truy vấn tổng đoạn và cập nhật một giá trị.
    </p>
    <p>
        Lợi thế của cây chỉ số nhị phân là nó cho phép chúng ta cập nhật các giá trị mảng một cách hiệu quả giữa các truy vấn tổng. Điều này sẽ không thể thực hiện được nếu dùng mảng tổng tiền tố, vì sau mỗi lần cập nhật, sẽ cần phải xây dựng lại toàn bộ mảng tổng tiền tố trong thời gian \(O(n)\).
    </p>

    <h3>Cấu trúc</h3>
    <p>
        Mặc dù tên gọi là cây, nó thường được biểu diễn dưới dạng mảng. Chúng ta giả sử mảng được đánh chỉ số từ 1 (1-indexed). Gọi \(p(k)\) là lũy thừa lớn nhất của hai là ước của \(k\). Chúng ta lưu trữ cây chỉ số nhị phân dưới dạng mảng <code>tree</code> sao cho:
        $$ tree[k] = sum_q(k - p(k) + 1, k) $$
        tức là mỗi vị trí \(k\) chứa tổng của một đoạn có độ dài \(p(k)\) kết thúc tại \(k\).
    </p>

    <div class="graphic-box">
        <svg width="500" height="200" viewBox="0 0 500 200">
            <defs>
                <marker id="arrowUp" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
                    <path d="M0,10 L5,0 L10,10 z" fill="#333" />
                </marker>
            </defs>
            
            <g transform="translate(20, 160)">
                <text x="25" y="20" text-anchor="middle">1</text>
                <text x="75" y="20" text-anchor="middle">2</text>
                <text x="125" y="20" text-anchor="middle">3</text>
                <text x="175" y="20" text-anchor="middle">4</text>
                <text x="225" y="20" text-anchor="middle">5</text>
                <text x="275" y="20" text-anchor="middle">6</text>
                <text x="325" y="20" text-anchor="middle">7</text>
                <text x="375" y="20" text-anchor="middle">8</text>
            </g>

            <rect x="25" y="130" width="40" height="20" class="bit-bar" rx="3"/>
            
            <rect x="25" y="100" width="90" height="20" class="bit-bar" rx="3"/>
            <line x1="70" y1="130" x2="70" y2="120" stroke="#333"/>
            
            <rect x="125" y="130" width="40" height="20" class="bit-bar" rx="3"/>
            
            <rect x="25" y="70" width="190" height="20" class="bit-bar" rx="3"/>
            <line x1="170" y1="130" x2="170" y2="90" stroke="#333"/>
            
            <rect x="225" y="130" width="40" height="20" class="bit-bar" rx="3"/>
            
            <rect x="225" y="100" width="90" height="20" class="bit-bar" rx="3"/>
            <line x1="270" y1="130" x2="270" y2="120" stroke="#333"/>
            
            <rect x="325" y="130" width="40" height="20" class="bit-bar" rx="3"/>
            
            <rect x="25" y="40" width="390" height="20" class="bit-bar" rx="3"/>
            <line x1="370" y1="130" x2="370" y2="60" stroke="#333"/>
            
            <text x="450" y="55" font-size="12">p(8)=8</text>
            <text x="450" y="85" font-size="12">p(4)=4</text>
            <text x="450" y="115" font-size="12">p(6)=2</text>
            <text x="450" y="145" font-size="12">p(x)=1</text>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 9.3: Cây chỉ số nhị phân: mỗi chỉ số k quản lý đoạn độ dài p(k)</div>
    </div>

    <p>
        Bất kỳ giá trị nào của \(sum_q(1,k)\) đều có thể được tính toán trong thời gian \(O(\log n)\), vì một đoạn \([1,k]\) luôn có thể được chia thành \(O(\log n)\) đoạn có tổng được lưu trữ trong cây. Ví dụ, đoạn \([1,7]\) bao gồm các đoạn: \([1,4]\), \([5,6]\) và \([7,7]\).
    </p>

    <h3>Cài đặt</h3>
    <p>
        Các thao tác có thể được cài đặt hiệu quả bằng các phép toán bit. Sự thật quan trọng là chúng ta có thể tính \(p(k)\) bằng công thức <code>k&-k</code>. Hàm sau tính giá trị của \(sum_q(1,k)\):
    </p>

<pre><code><span class="cpp-keyword">int</span> <span class="cpp-func">sum</span>(<span class="cpp-keyword">int</span> k) {
    <span class="cpp-keyword">int</span> s = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">while</span> (k &gt;= <span class="cpp-number">1</span>) {
        s += tree[k];
        k -= k&amp;-k;
    }
    <span class="cpp-keyword">return</span> s;
}</code></pre>

    <p>
        Hàm sau tăng giá trị mảng tại vị trí \(k\) thêm \(x\):
    </p>

<pre><code><span class="cpp-keyword">void</span> <span class="cpp-func">add</span>(<span class="cpp-keyword">int</span> k, <span class="cpp-keyword">int</span> x) {
    <span class="cpp-keyword">while</span> (k &lt;= n) {
        tree[k] += x;
        k += k&amp;-k;
    }
}</code></pre>

    <h2 id="sec9.3">9.3 Cây phân đoạn (Segment Tree)</h2>
    <p>
        Cây phân đoạn là một cấu trúc dữ liệu hỗ trợ hai thao tác: xử lý truy vấn đoạn và cập nhật một giá trị mảng. Cây phân đoạn có thể hỗ trợ truy vấn tổng, truy vấn min/max và nhiều truy vấn khác sao cho cả hai thao tác đều hoạt động trong thời gian \(O(\log n)\).
    </p>
    <p>
        So với cây chỉ số nhị phân, lợi thế của cây phân đoạn là nó là một cấu trúc dữ liệu tổng quát hơn. Tuy nhiên, cây phân đoạn yêu cầu nhiều bộ nhớ hơn và khó cài đặt hơn một chút.
    </p>

    <h3>Cấu trúc</h3>
    <p>
        Cây phân đoạn là một cây nhị phân sao cho các nút ở tầng dưới cùng của cây tương ứng với các phần tử mảng, và các nút khác chứa thông tin cần thiết để xử lý truy vấn đoạn. Chúng ta giả sử kích thước mảng là lũy thừa của hai và sử dụng chỉ số bắt đầu từ 0. Nếu kích thước mảng không phải là lũy thừa của hai, ta có thể thêm các phần tử thừa.
    </p>
    
    <div class="graphic-box">
        <svg width="500" height="250" viewBox="0 0 500 250">
            <circle cx="250" cy="30" r="20" class="tree-node"/> <text x="250" y="35" text-anchor="middle" font-weight="bold">39</text>
            
            <line x1="250" y1="50" x2="125" y2="90" stroke="#333"/>
            <line x1="250" y1="50" x2="375" y2="90" stroke="#333"/>
            <circle cx="125" cy="90" r="20" class="tree-node"/> <text x="125" y="95" text-anchor="middle">22</text>
            <circle cx="375" cy="90" r="20" class="tree-node"/> <text x="375" y="95" text-anchor="middle">17</text>
            
            <line x1="125" y1="110" x2="62" y2="150" stroke="#333"/>
            <line x1="125" y1="110" x2="187" y2="150" stroke="#333"/>
            <line x1="375" y1="110" x2="312" y2="150" stroke="#333"/>
            <line x1="375" y1="110" x2="437" y2="150" stroke="#333"/>
            
            <circle cx="62" cy="150" r="15" class="tree-node"/> <text x="62" y="155" text-anchor="middle">13</text>
            <circle cx="187" cy="150" r="15" class="tree-node"/> <text x="187" y="155" text-anchor="middle">9</text>
            <circle cx="312" cy="150" r="15" class="tree-node"/> <text x="312" y="155" text-anchor="middle">9</text>
            <circle cx="437" cy="150" r="15" class="tree-node"/> <text x="437" y="155" text-anchor="middle">8</text>
            
            <g transform="translate(0, 60)">
                <line x1="62" y1="105" x2="31" y2="135" stroke="#333"/> <circle cx="31" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="31" y="140" text-anchor="middle" font-size="12">5</text>
                <line x1="62" y1="105" x2="93" y2="135" stroke="#333"/> <circle cx="93" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="93" y="140" text-anchor="middle" font-size="12">8</text>
                
                <line x1="187" y1="105" x2="156" y2="135" stroke="#333"/> <circle cx="156" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="156" y="140" text-anchor="middle" font-size="12">6</text>
                <line x1="187" y1="105" x2="218" y2="135" stroke="#333"/> <circle cx="218" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="218" y="140" text-anchor="middle" font-size="12">3</text>
                
                <line x1="312" y1="105" x2="281" y2="135" stroke="#333"/> <circle cx="281" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="281" y="140" text-anchor="middle" font-size="12">2</text>
                <line x1="312" y1="105" x2="343" y2="135" stroke="#333"/> <circle cx="343" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="343" y="140" text-anchor="middle" font-size="12">7</text>
                
                <line x1="437" y1="105" x2="406" y2="135" stroke="#333"/> <circle cx="406" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="406" y="140" text-anchor="middle" font-size="12">2</text>
                <line x1="437" y1="105" x2="468" y2="135" stroke="#333"/> <circle cx="468" cy="135" r="12" class="tree-node" style="fill:#ecf0f1"/> <text x="468" y="140" text-anchor="middle" font-size="12">6</text>
            </g>
            <text x="250" y="240" text-anchor="middle" font-style="italic">Các lá chứa mảng: [5, 8, 6, 3, 2, 7, 2, 6]</text>
        </svg>
    </div>

    <p>
        Cây phân đoạn được lưu trữ dưới dạng mảng <code>tree</code> kích thước \(2n\). Các phần tử của mảng gốc được lưu trữ tại các vị trí \(n \dots 2n-1\). Các nút trong được lưu trữ tại \(1 \dots n-1\).
    </p>
    <p>
        Hàm sau tính giá trị của \(sum_q(a,b)\):
    </p>

<pre><code><span class="cpp-keyword">int</span> <span class="cpp-func">sum</span>(<span class="cpp-keyword">int</span> a, <span class="cpp-keyword">int</span> b) {
    a += n; b += n;
    <span class="cpp-keyword">int</span> s = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">while</span> (a &lt;= b) {
        <span class="cpp-keyword">if</span> (a%<span class="cpp-number">2</span> == <span class="cpp-number">1</span>) s += tree[a++];
        <span class="cpp-keyword">if</span> (b%<span class="cpp-number">2</span> == <span class="cpp-number">0</span>) s += tree[b--];
        a /= <span class="cpp-number">2</span>; b /= <span class="cpp-number">2</span>;
    }
    <span class="cpp-keyword">return</span> s;
}</code></pre>

    <p>
        Hàm sau tăng giá trị mảng tại vị trí \(k\) thêm \(x\):
    </p>

<pre><code><span class="cpp-keyword">void</span> <span class="cpp-func">add</span>(<span class="cpp-keyword">int</span> k, <span class="cpp-keyword">int</span> x) {
    k += n;
    tree[k] += x;
    <span class="cpp-keyword">for</span> (k /= <span class="cpp-number">2</span>; k &gt;= <span class="cpp-number">1</span>; k /= <span class="cpp-number">2</span>) {
        tree[k] = tree[<span class="cpp-number">2</span>*k] + tree[<span class="cpp-number">2</span>*k+<span class="cpp-number">1</span>];
    }
}</code></pre>

    <h2 id="sec9.4">9.4 Các kỹ thuật bổ sung (Additional techniques)</h2>
    <h3>Nén chỉ số (Index compression)</h3>
    <p>
        Một giới hạn của các cấu trúc dữ liệu dựa trên mảng là các phần tử được lập chỉ mục bằng các số nguyên liên tiếp. Khó khăn nảy sinh khi cần sử dụng các chỉ số lớn, ví dụ \(10^9\).
    </p>
    <p>
        Chúng ta có thể vượt qua giới hạn này bằng cách sử dụng <strong>nén chỉ số</strong>. Ý tưởng là thay thế mỗi chỉ số gốc \(x\) bằng \(c(x)\) sao cho thứ tự các chỉ số không đổi (nếu \(a < b\) thì \(c(a) < c(b)\)). Các chỉ số mới sẽ là \(1, 2, 3, \dots\).
    </p>

    <h3>Cập nhật đoạn (Range updates)</h3>
    <p>
        Nếu chúng ta cần cập nhật các giá trị trong một đoạn \([a,b]\) (ví dụ: tăng tất cả lên \(x\)) và truy vấn giá trị đơn lẻ, chúng ta có thể sử dụng <strong>mảng hiệu</strong> (difference array).
    </p>
    <p>
        Mảng hiệu \(D\) được định nghĩa sao cho mảng gốc là mảng tổng tiền tố của \(D\). Để tăng các giá trị trong đoạn \([a,b]\) thêm \(x\), ta chỉ cần tăng \(D[a]\) thêm \(x\) và giảm \(D[b+1]\) đi \(x\).
    </p>

</body>
</html>