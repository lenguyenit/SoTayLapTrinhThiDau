<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPH - Chương 25: Lý thuyết trò chơi</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 { margin-top: 40px; }
        p { margin-bottom: 15px; text-align: justify; }
        
        /* Code styling */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f1f3f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d63384;
        }
        
        /* Syntax highlighting */
        .cpp-keyword { color: #0000ff; font-weight: bold; }
        .cpp-type { color: #2b91af; }
        .cpp-number { color: #098658; }
        .cpp-func { color: #795e26; }
        .cpp-comment { color: #008000; font-style: italic; }

        /* Graphics Containers */
        .graphic-box {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        /* SVG Styling */
        svg text { font-family: "Segoe UI", sans-serif; font-size: 14px; text-anchor: middle; dominant-baseline: central; font-weight: bold; }
        .node-circle { fill: #fff; stroke: #2c3e50; stroke-width: 2; }
        .node-win { fill: #e8f5e9; stroke: #2e7d32; stroke-width: 2; } /* Winning State - Green */
        .node-lose { fill: #ffebee; stroke: #c62828; stroke-width: 2; } /* Losing State - Red */
        .edge-line { stroke: #555; stroke-width: 2; marker-end: url(#arrowGame); }
        .nim-heap { fill: #3498db; stroke: #2980b9; stroke-width: 1; }

        /* TOC */
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc a { text-decoration: none; color: #007bff; font-weight: 500; }
    </style>
</head>
<body>

    <div class="toc">
        <h3>Mục lục - Chương 25</h3>
        <ul>
            <li><a href="#intro">Lý thuyết trò chơi</a></li>
            <li><a href="#sec25.1">25.1 Trạng thái trò chơi</a></li>
            <li><a href="#sec25.2">25.2 Trò chơi Nim</a></li>
            <li><a href="#sec25.3">25.3 Định lý Sprague-Grundy</a></li>
        </ul>
    </div>

    <h1 id="intro">Chương 25: Lý thuyết trò chơi (Game theory)</h1>
    <p>
        Trong chương này, chúng ta sẽ xem xét các trò chơi dành cho hai người chơi với thông tin hoàn hảo, không có yếu tố may rủi (như tung xúc xắc) và các người chơi luân phiên đi nước đi của mình. Người chơi đầu tiên không thể thực hiện nước đi sẽ thua cuộc (quy tắc chơi thông thường).
    </p>
    <p>
        Mục tiêu là tìm ra chiến thuật thắng cho người đi trước hoặc người đi sau, giả sử cả hai đều chơi tối ưu. Các trò chơi như vậy gọi là <strong>trò chơi công bằng</strong> (impartial games).
    </p>

    <h2 id="sec25.1">25.1 Trạng thái trò chơi (Game states)</h2>
    <p>
        Mọi trạng thái trong trò chơi đều có thể được phân loại là <strong>thắng</strong> (winning) hoặc <strong>thua</strong> (losing).
    </p>
    <ul>
        <li><strong>Trạng thái thua (L):</strong> Là trạng thái mà người chơi đến lượt đi sẽ thua nếu đối thủ chơi tối ưu. Trạng thái kết thúc (không còn nước đi) luôn là trạng thái thua.</li>
        <li><strong>Trạng thái thắng (W):</strong> Là trạng thái mà người chơi đến lượt đi có thể thực hiện một nước đi chuyển trò chơi sang trạng thái thua cho đối thủ.</li>
    </ul>
    <p>
        Quy tắc xác định đệ quy:
        <ul>
            <li>Một trạng thái là <strong>thua</strong> nếu mọi nước đi từ nó đều dẫn đến trạng thái thắng.</li>
            <li>Một trạng thái là <strong>thắng</strong> nếu tồn tại ít nhất một nước đi dẫn đến trạng thái thua.</li>
        </ul>
    </p>

    <div class="graphic-box">
        <svg width="400" height="250" viewBox="0 0 400 250">
            <defs>
                <marker id="arrowGame" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                    <path d="M0,0 L0,6 L9,3 z" fill="#555" />
                </marker>
            </defs>

            <g id="game-edges">
                <line x1="200" y1="30" x2="100" y2="100" class="edge-line"/>
                <line x1="200" y1="30" x2="200" y2="100" class="edge-line"/>
                <line x1="200" y1="30" x2="300" y2="100" class="edge-line"/>
                
                <line x1="100" y1="100" x2="200" y2="100" class="edge-line"/>
                <line x1="100" y1="100" x2="300" y2="100" class="edge-line"/>
                <line x1="100" y1="100" x2="200" y2="200" class="edge-line"/>
                
                <line x1="200" y1="100" x2="300" y2="100" class="edge-line"/>
                <line x1="200" y1="100" x2="200" y2="200" class="edge-line"/>
                
                <line x1="300" y1="100" x2="200" y2="200" class="edge-line"/>
            </g>

            <g id="game-nodes">
                <circle cx="200" cy="200" r="18" class="node-lose"/> <text x="200" y="200">0 (L)</text>
                
                <circle cx="300" cy="100" r="18" class="node-win"/> <text x="300" y="100">1 (W)</text>
                
                <circle cx="200" cy="100" r="18" class="node-win"/> <text x="200" y="100">2 (W)</text>
                
                <circle cx="100" cy="100" r="18" class="node-win"/> <text x="100" y="100">3 (W)</text>
                
                <circle cx="200" cy="30" r="18" class="node-lose"/> <text x="200" y="30">4 (L)</text>
            </g>
            
            <text x="200" y="240" font-size="13" fill="#555">Trò chơi bốc sỏi (1, 2, hoặc 3 viên)</text>
        </svg>
    </div>

    <h3>Cài đặt</h3>
    <p>
        Chúng ta có thể sử dụng quy hoạch động hoặc đệ quy có nhớ để xác định trạng thái.
    </p>

<pre><code><span class="cpp-keyword">int</span> memo[N]; <span class="cpp-comment">// -1: chưa tính, 0: Thua, 1: Thắng</span>

<span class="cpp-keyword">int</span> <span class="cpp-func">solve</span>(<span class="cpp-keyword">int</span> k) {
    <span class="cpp-keyword">if</span> (k == <span class="cpp-number">0</span>) <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>; <span class="cpp-comment">// Trạng thái 0 là Thua</span>
    <span class="cpp-keyword">if</span> (memo[k] != <span class="cpp-number">-1</span>) <span class="cpp-keyword">return</span> memo[k];

    <span class="cpp-comment">// Thử tất cả các nước đi có thể (ví dụ bốc 1, 2, hoặc 3)</span>
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> x : {<span class="cpp-number">1</span>, <span class="cpp-number">2</span>, <span class="cpp-number">3</span>}) {
        <span class="cpp-keyword">if</span> (k - x &gt;= <span class="cpp-number">0</span> && <span class="cpp-func">solve</span>(k - x) == <span class="cpp-number">0</span>) {
            <span class="cpp-comment">// Nếu dẫn đến thế thua cho đối thủ -> Mình thắng</span>
            <span class="cpp-keyword">return</span> memo[k] = <span class="cpp-number">1</span>;
        }
    }
    <span class="cpp-comment">// Tất cả nước đi đều dẫn đến thế thắng cho đối thủ -> Mình thua</span>
    <span class="cpp-keyword">return</span> memo[k] = <span class="cpp-number">0</span>;
}</code></pre>

    <h2 id="sec25.2">25.2 Trò chơi Nim (Nim Game)</h2>
    <p>
        Trò chơi Nim là một trò chơi cơ bản nhưng cực kỳ quan trọng. Có \(n\) đống sỏi, đống thứ \(i\) có \(x_i\) viên. Mỗi lượt, người chơi chọn một đống và lấy đi bất kỳ số lượng sỏi nào (\(>0\)).
    </p>
    <p>
        Trạng thái của trò chơi được xác định bởi <strong>tổng XOR</strong> (Nim-sum) của kích thước các đống:
        $$ s = x_1 \oplus x_2 \oplus \dots \oplus x_n $$
    </p>
    <ul>
        <li>Nếu \(s = 0\): Trạng thái <strong>thua</strong> (Losing).</li>
        <li>Nếu \(s \neq 0\): Trạng thái <strong>thắng</strong> (Winning).</li>
    </ul>
    <p>
        <strong>Chiến thuật thắng:</strong> Nếu \(s \neq 0\), luôn tồn tại một nước đi biến tổng XOR thành 0. Nếu \(s = 0\), bất kỳ nước đi nào cũng sẽ làm tổng XOR khác 0.
    </p>

    <div class="graphic-box">
        <svg width="400" height="150" viewBox="0 0 400 150">
            <g transform="translate(80, 100)">
                <rect x="0" y="0" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-25" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-50" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-75" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-100" width="20" height="20" class="nim-heap"/>
                <text x="10" y="35">5 (101)</text>
            </g>

            <g transform="translate(180, 100)">
                <rect x="0" y="0" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-25" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-50" width="20" height="20" class="nim-heap"/>
                <text x="10" y="35">3 (011)</text>
            </g>

            <g transform="translate(280, 100)">
                <rect x="0" y="0" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-25" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-50" width="20" height="20" class="nim-heap"/>
                <rect x="0" y="-75" width="20" height="20" class="nim-heap"/>
                <text x="10" y="35">4 (100)</text>
            </g>
            
            <text x="200" y="10" font-weight="bold">Tổng XOR: 5 ⊕ 3 ⊕ 4 = 2 (≠ 0) -> Thắng</text>
        </svg>
    </div>

    <h3>Cài đặt</h3>
<pre><code><span class="cpp-keyword">int</span> nim_sum = <span class="cpp-number">0</span>;
<span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">0</span>; i &lt; n; i++) {
    nim_sum ^= x[i];
}

<span class="cpp-keyword">if</span> (nim_sum == <span class="cpp-number">0</span>) cout &lt;&lt; <span class="cpp-string">"Thua\n"</span>;
<span class="cpp-keyword">else</span> cout &lt;&lt; <span class="cpp-string">"Thắng\n"</span>;</code></pre>

    <h2 id="sec25.3">25.3 Định lý Sprague-Grundy (Sprague-Grundy theorem)</h2>
    <p>
        Định lý này tổng quát hóa Nim cho mọi trò chơi công bằng.
        Mọi trạng thái trò chơi đều tương đương với một đống Nim có kích thước nhất định, gọi là <strong>số Grundy</strong> (hoặc nim-value) của trạng thái đó.
    </p>
    <p>
        Số Grundy của trạng thái \(u\), ký hiệu \(g(u)\), được định nghĩa là:
        $$ g(u) = \text{mex}(\{g(v) \mid u \to v\}) $$
        Trong đó, \(\text{mex}\) (Minimum Excluded value) của một tập hợp số nguyên không âm là số nguyên không âm nhỏ nhất <strong>không</strong> nằm trong tập hợp đó.
        Ví dụ: \(\text{mex}(\{0, 1, 3\}) = 2\), \(\text{mex}(\{1, 2\}) = 0\).
    </p>
    <ul>
        <li>Nếu \(g(u) = 0\): Trạng thái thua.</li>
        <li>Nếu \(g(u) \neq 0\): Trạng thái thắng.</li>
    </ul>
    <p>
        <strong>Trò chơi ghép (Composite Games):</strong> Nếu một trò chơi bao gồm nhiều trò chơi con độc lập, số Grundy của trạng thái tổng hợp bằng tổng XOR của các số Grundy của các trò chơi con.
    </p>

    <div class="graphic-box">
        <svg width="350" height="200" viewBox="0 0 350 200">
            <defs>
                <marker id="arrowGrundy" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                    <path d="M0,0 L0,6 L9,3 z" fill="#555" />
                </marker>
            </defs>

            <g id="grundy-edges">
                <line x1="175" y1="40" x2="100" y2="120" class="edge-line" marker-end="url(#arrowGrundy)"/>
                <line x1="175" y1="40" x2="175" y2="120" class="edge-line" marker-end="url(#arrowGrundy)"/>
                <line x1="175" y1="40" x2="250" y2="120" class="edge-line" marker-end="url(#arrowGrundy)"/>
            </g>

            <g id="grundy-nodes">
                <circle cx="100" cy="120" r="18" class="node-circle"/> <text x="100" y="120">g=0</text>
                <circle cx="175" cy="120" r="18" class="node-circle"/> <text x="175" y="120">g=1</text>
                <circle cx="250" cy="120" r="18" class="node-circle"/> <text x="250" y="120">g=3</text>
                
                <circle cx="175" cy="40" r="22" class="node-win"/> <text x="175" y="40">g=?</text>
            </g>
            
            <text x="175" y="170" font-size="13" fill="#555">mex({0, 1, 3}) = 2</text>
            <text x="175" y="190" font-size="13" fill="#555">Vậy g(parent) = 2</text>
        </svg>
    </div>

    <h3>Cài đặt tính số Grundy</h3>
<pre><code><span class="cpp-type">int</span> memo_grundy[N];

<span class="cpp-keyword">int</span> <span class="cpp-func">grundy</span>(<span class="cpp-keyword">int</span> u) {
    <span class="cpp-keyword">if</span> (memo_grundy[u] != <span class="cpp-number">-1</span>) <span class="cpp-keyword">return</span> memo_grundy[u];

    <span class="cpp-type">set</span>&lt;<span class="cpp-keyword">int</span>&gt; reachable_values;
    <span class="cpp-comment">// Giả sử move(u) trả về danh sách các trạng thái tiếp theo</span>
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> v : move(u)) {
        reachable_values.insert(<span class="cpp-func">grundy</span>(v));
    }

    <span class="cpp-comment">// Tính Mex</span>
    <span class="cpp-keyword">int</span> res = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">while</span> (reachable_values.count(res)) {
        res++;
    }
    <span class="cpp-keyword">return</span> memo_grundy[u] = res;
}</code></pre>

</body>
</html>