<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPH - Chương 18: Truy vấn cây</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 { margin-top: 40px; }
        p { margin-bottom: 15px; text-align: justify; }
        
        /* Code styling */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f1f3f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d63384;
        }
        
        /* Syntax highlighting */
        .cpp-keyword { color: #0000ff; font-weight: bold; }
        .cpp-type { color: #2b91af; }
        .cpp-number { color: #098658; }
        .cpp-func { color: #795e26; }
        .cpp-comment { color: #008000; font-style: italic; }

        /* Graphics Containers */
        .graphic-box {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        /* SVG Styling */
        svg text { font-family: "Segoe UI", sans-serif; font-size: 14px; text-anchor: middle; dominant-baseline: central; font-weight: bold; }
        .node-circle { fill: #fff; stroke: #2c3e50; stroke-width: 2; }
        .node-highlight { fill: #e3f2fd; stroke: #2196f3; stroke-width: 2; }
        .node-lca { fill: #fff9c4; stroke: #fbc02d; stroke-width: 2; }
        .edge-line { stroke: #555; stroke-width: 2; }
        .jump-line { fill: none; stroke-width: 2; stroke-dasharray: 4; marker-end: url(#arrowJump); }
        .array-rect { fill: #fff; stroke: #333; stroke-width: 1; }
        .array-highlight { fill: #bbdefb; }
        .arrow-head { fill: #555; }

        /* TOC */
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc a { text-decoration: none; color: #007bff; font-weight: 500; }
    </style>
</head>
<body>

    <div class="toc">
        <h3>Mục lục - Chương 18</h3>
        <ul>
            <li><a href="#intro">Truy vấn cây</a></li>
            <li><a href="#sec18.1">18.1 Tìm tổ tiên</a></li>
            <li><a href="#sec18.2">18.2 Cây con và đường đi</a></li>
            <li><a href="#sec18.3">18.3 Tổ tiên chung gần nhất (LCA)</a></li>
            <li><a href="#sec18.4">18.4 Thuật toán offline</a></li>
        </ul>
    </div>

    <h1 id="intro">Chương 18: Truy vấn cây (Tree queries)</h1>
    <p>
        Chương này thảo luận về các kỹ thuật xử lý truy vấn trên cây. Các truy vấn điển hình bao gồm:
    </p>
    <ul>
        <li>Tổ tiên thứ \(k\) của một nút là gì?</li>
        <li>Tổng các giá trị trong cây con của một nút là bao nhiêu?</li>
        <li>Tổng các giá trị trên đường đi giữa hai nút là bao nhiêu?</li>
        <li>Tổ tiên chung gần nhất của hai nút là gì?</li>
    </ul>

    <h2 id="sec18.1">18.1 Tìm tổ tiên (Finding ancestors)</h2>
    <p>
        Tổ tiên thứ \(k\) của một nút \(x\) là nút mà chúng ta sẽ đến nếu di chuyển \(k\) bước lên trên từ \(x\) về phía gốc. Gọi \(ancestor(x,k)\) là tổ tiên thứ \(k\) của nút \(x\).
    </p>
    <p>
        Một cách dễ dàng để tính \(ancestor(x,k)\) là thực hiện \(k\) bước di chuyển. Tuy nhiên, độ phức tạp thời gian là \(O(k)\), có thể chậm nếu \(k\) lớn.
    </p>
    <p>
        Chúng ta có thể sử dụng kỹ thuật <strong>nhân đôi</strong> (binary lifting) để tính toán bất kỳ tổ tiên nào trong thời gian \(O(\log k)\). Quá trình tiền xử lý mất \(O(n \log n)\).
    </p>
    <p>
        Ý tưởng là tính trước bảng <code>up[x][i]</code>: tổ tiên thứ \(2^i\) của nút \(x\).
        $$ up[x][i] = up[up[x][i-1]][i-1] $$
        Nghĩa là, để nhảy \(2^i\) bước, ta nhảy \(2^{i-1}\) bước đến nút trung gian, rồi từ nút đó nhảy tiếp \(2^{i-1}\) bước nữa.
    </p>

    <div class="graphic-box">
        <svg width="350" height="300" viewBox="0 0 350 300">
            <defs>
                <marker id="arrowJump" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
                    <path d="M0,0 L8,4 L0,8 z" fill="#555" />
                </marker>
            </defs>

            <g id="bl-edges">
                <line x1="175" y1="30" x2="175" y2="80" class="edge-line"/> <line x1="175" y1="80" x2="175" y2="130" class="edge-line"/> <line x1="175" y1="130" x2="175" y2="180" class="edge-line"/> <line x1="175" y1="180" x2="175" y2="230" class="edge-line"/> <line x1="175" y1="230" x2="175" y2="280" class="edge-line"/> </g>

            <g id="bl-jumps">
                <path d="M190,230 Q210,205 190,180" class="jump-line" style="stroke:#2196f3"/>
                
                <path d="M160,230 Q110,180 160,130" class="jump-line" style="stroke:#e67e22"/>
                
                <path d="M190,230 Q260,130 190,30" class="jump-line" style="stroke:#9b59b6"/>
            </g>

            <g id="bl-nodes">
                <circle cx="175" cy="30" r="15" class="node-circle"/> <text x="175" y="30">1</text>
                <circle cx="175" cy="80" r="15" class="node-circle"/> <text x="175" y="80">2</text>
                <circle cx="175" cy="130" r="15" class="node-circle"/> <text x="175" y="130">3</text>
                <circle cx="175" cy="180" r="15" class="node-circle"/> <text x="175" y="180">4</text>
                <circle cx="175" cy="230" r="15" class="node-highlight"/> <text x="175" y="230">5</text>
                <circle cx="175" cy="280" r="15" class="node-circle"/> <text x="175" y="280">6</text>
            </g>
            
            <text x="230" y="205" font-size="12" fill="#2196f3">2^0</text>
            <text x="130" y="180" font-size="12" fill="#e67e22">2^1</text>
            <text x="240" y="130" font-size="12" fill="#9b59b6">2^2</text>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 18.1: Các bước nhảy nhị phân từ nút 5</div>
    </div>

    <h3>Cài đặt</h3>
    <p>Đầu tiên, chúng ta tính toán bảng <code>up</code>:</p>

<pre><code><span class="cpp-keyword">int</span> up[N][LOG]; <span class="cpp-comment">// LOG thường khoảng 20</span>

<span class="cpp-comment">// Khởi tạo up[i][0] là cha trực tiếp của i</span>
<span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) up[i][<span class="cpp-number">0</span>] = parent[i];

<span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> j = <span class="cpp-number">1</span>; j &lt; LOG; j++) {
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) {
        <span class="cpp-keyword">if</span> (up[i][j-<span class="cpp-number">1</span>] != <span class="cpp-number">0</span>)
            up[i][j] = up[up[i][j-<span class="cpp-number">1</span>]][j-<span class="cpp-number">1</span>];
        <span class="cpp-keyword">else</span>
            up[i][j] = <span class="cpp-number">0</span>;
    }
}</code></pre>

    <p>Sau đó, hàm tìm tổ tiên thứ \(k\):</p>

<pre><code><span class="cpp-keyword">int</span> <span class="cpp-func">get_kth_ancestor</span>(<span class="cpp-keyword">int</span> node, <span class="cpp-keyword">int</span> k) {
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">0</span>; i &lt; LOG; i++) {
        <span class="cpp-keyword">if</span> ((k &gt;&gt; i) & <span class="cpp-number">1</span>) {
            node = up[node][i];
        }
    }
    <span class="cpp-keyword">return</span> node;
}</code></pre>

    <h2 id="sec18.2">18.2 Cây con và đường đi (Subtrees and paths)</h2>
    <p>
        Một kỹ thuật mạnh mẽ để xử lý các truy vấn cây con là "trải phẳng" (flatten) cây thành một mảng bằng cách sử dụng duyệt DFS (còn gọi là Euler Tour).
    </p>
    <p>
        Chúng ta lưu lại thời điểm bắt đầu thăm (<code>in[s]</code>) và thời điểm kết thúc thăm (<code>out[s]</code>) cho mỗi nút \(s\). Khi đó, tất cả các nút thuộc cây con của \(s\) sẽ nằm trong khoảng chỉ số <code>[in[s], out[s]]</code> trong mảng thứ tự duyệt.
    </p>

    <div class="graphic-box">
        <svg width="500" height="220" viewBox="0 0 500 220">
            <g id="flat-edges">
                <line x1="250" y1="30" x2="150" y2="80" class="edge-line"/> <line x1="250" y1="30" x2="350" y2="80" class="edge-line"/> <line x1="150" y1="80" x2="100" y2="130" class="edge-line"/> <line x1="150" y1="80" x2="200" y2="130" class="edge-line"/> </g>

            <g id="flat-nodes">
                <circle cx="250" cy="30" r="15" class="node-circle"/> <text x="250" y="30">1</text>
                <circle cx="150" cy="80" r="15" class="node-circle"/> <text x="150" y="80">2</text>
                <circle cx="350" cy="80" r="15" class="node-circle"/> <text x="350" y="80">3</text>
                <circle cx="100" cy="130" r="15" class="node-circle"/> <text x="100" y="130">4</text>
                <circle cx="200" cy="130" r="15" class="node-circle"/> <text x="200" y="130">5</text>
            </g>

            <g transform="translate(50, 170)">
                <text x="-30" y="20" font-weight="bold">Mảng:</text>
                <rect x="0" y="0" width="40" height="40" class="array-rect array-highlight"/> <text x="20" y="25">1</text>
                <rect x="40" y="0" width="40" height="40" class="array-rect array-highlight"/> <text x="60" y="25">2</text>
                <rect x="80" y="0" width="40" height="40" class="array-rect array-highlight"/> <text x="100" y="25">4</text>
                <rect x="120" y="0" width="40" height="40" class="array-rect array-highlight"/> <text x="140" y="25">5</text>
                <rect x="160" y="0" width="40" height="40" class="array-rect array-highlight"/> <text x="180" y="25">3</text>
                
                <line x1="40" y1="45" x2="160" y2="45" stroke="#2196f3" stroke-width="2"/>
                <line x1="40" y1="42" x2="40" y2="48" stroke="#2196f3" stroke-width="2"/>
                <line x1="160" y1="42" x2="160" y2="48" stroke="#2196f3" stroke-width="2"/>
                <text x="100" y="60" font-size="12" fill="#2196f3">Cây con của 2: [2, 4, 5]</text>
            </g>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 18.2: Ánh xạ cây con thành một đoạn liên tiếp trên mảng</div>
    </div>

    <p>
        Bằng cách này, các truy vấn trên cây con (như tính tổng giá trị) trở thành truy vấn đoạn trên mảng, có thể giải quyết hiệu quả bằng Cây chỉ số nhị phân (BIT) hoặc Cây phân đoạn trong thời gian \(O(\log n)\).
    </p>

    <h3>Cài đặt DFS trải phẳng</h3>
<pre><code><span class="cpp-keyword">int</span> timer;
<span class="cpp-keyword">int</span> in[N], out[N];

<span class="cpp-keyword">void</span> <span class="cpp-func">dfs</span>(<span class="cpp-keyword">int</span> s, <span class="cpp-keyword">int</span> e) {
    in[s] = ++timer;
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">auto</span> u : adj[s]) {
        <span class="cpp-keyword">if</span> (u != e) <span class="cpp-func">dfs</span>(u, s);
    }
    out[s] = timer;
}</code></pre>

    <h2 id="sec18.3">18.3 Tổ tiên chung gần nhất (Lowest Common Ancestor - LCA)</h2>
    <p>
        Tổ tiên chung gần nhất của hai nút \(a\) và \(b\) là nút thấp nhất trong cây là tổ tiên của cả \(a\) và \(b\).
    </p>
    
    <div class="graphic-box">
        <svg width="300" height="200" viewBox="0 0 300 200">
            <g id="lca-edges">
                <line x1="150" y1="20" x2="100" y2="70" class="edge-line"/>
                <line x1="150" y1="20" x2="200" y2="70" class="edge-line"/>
                <line x1="100" y1="70" x2="60" y2="120" class="edge-line"/>
                <line x1="100" y1="70" x2="140" y2="120" class="edge-line"/>
                <line x1="200" y1="70" x2="180" y2="120" class="edge-line"/>
                <line x1="200" y1="70" x2="240" y2="120" class="edge-line"/>
                
                <path d="M60,120 L100,70 L150,20" fill="none" stroke="#e67e22" stroke-width="4" opacity="0.3"/>
                <path d="M240,120 L200,70 L150,20" fill="none" stroke="#e67e22" stroke-width="4" opacity="0.3"/>
            </g>

            <g id="lca-nodes">
                <circle cx="150" cy="20" r="15" class="node-lca"/> <text x="150" y="20">1</text>
                <circle cx="100" cy="70" r="15" class="node-circle"/> <text x="100" y="70">2</text>
                <circle cx="200" cy="70" r="15" class="node-circle"/> <text x="200" y="70">3</text>
                <circle cx="60" cy="120" r="15" class="node-highlight"/> <text x="60" y="120">4</text>
                <circle cx="140" cy="120" r="15" class="node-circle"/> <text x="140" y="120">5</text>
                <circle cx="180" cy="120" r="15" class="node-circle"/> <text x="180" y="120">6</text>
                <circle cx="240" cy="120" r="15" class="node-highlight"/> <text x="240" y="120">7</text>
            </g>
            <text x="150" y="160" font-size="12">LCA(4, 7) = 1</text>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 18.3: Tổ tiên chung gần nhất của 4 và 7 là 1</div>
    </div>

    <h3>Phương pháp: Nhân đôi (Binary Lifting)</h3>
    <p>
        Chúng ta có thể sử dụng bảng <code>up</code> để tìm LCA trong thời gian \(O(\log n)\).
        Thuật toán hoạt động như sau:
    </p>
    <ol>
        <li>Di chuyển nút ở độ sâu lớn hơn lên sao cho hai nút \(a\) và \(b\) có cùng độ sâu.</li>
        <li>Nếu \(a = b\), thì LCA chính là \(a\).</li>
        <li>Sử dụng nhân đôi để nhảy lên cao nhất có thể mà không gặp nhau (tức là nhảy đến ngay dưới LCA). Chúng ta duyệt \(i\) từ lớn xuống nhỏ, nếu <code>up[a][i] != up[b][i]</code>, ta di chuyển cả hai nút lên \(2^i\) bước.</li>
        <li>Kết quả là <code>up[a][0]</code> (cha của nút \(a\) sau bước 3).</li>
    </ol>

    <h3>Cài đặt</h3>

<pre><code><span class="cpp-keyword">int</span> <span class="cpp-func">get_lca</span>(<span class="cpp-keyword">int</span> a, <span class="cpp-keyword">int</span> b) {
    <span class="cpp-keyword">if</span> (depth[a] &lt; depth[b]) swap(a, b);
    
    <span class="cpp-comment">// 1. Đưa về cùng độ sâu</span>
    a = <span class="cpp-func">get_kth_ancestor</span>(a, depth[a] - depth[b]);
    <span class="cpp-keyword">if</span> (a == b) <span class="cpp-keyword">return</span> a;

    <span class="cpp-comment">// 3. Nhảy lên cùng nhau (tìm ngay dưới LCA)</span>
    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = LOG - <span class="cpp-number">1</span>; i &gt;= <span class="cpp-number">0</span>; i--) {
        <span class="cpp-keyword">if</span> (up[a][i] != up[b][i]) {
            a = up[a][i];
            b = up[b][i];
        }
    }
    <span class="cpp-keyword">return</span> up[a][<span class="cpp-number">0</span>];
}</code></pre>

    <h3>Khoảng cách giữa hai nút</h3>
    <p>
        Khoảng cách giữa hai nút \(a\) và \(b\) có thể được tính bằng công thức:
        $$ dist(a,b) = depth[a] + depth[b] - 2 \cdot depth[LCA(a,b)] $$
    </p>

    <h2 id="sec18.4">18.4 Thuật toán offline (Offline algorithms)</h2>
    <p>
        Đôi khi chúng ta có thể trả lời các truy vấn hiệu quả hơn nếu chúng ta được phép xử lý chúng theo một thứ tự khác (offline) thay vì phải trả lời từng truy vấn ngay lập tức (online).
    </p>
    <p>
        Một kỹ thuật phổ biến là <strong>hợp nhất các cấu trúc dữ liệu</strong> (merging data structures), hay còn gọi là "small-to-large merging".
    </p>
    <p>
        Ví dụ: Với mỗi nút \(s\), đếm số lượng giá trị phân biệt trong cây con của nó. Chúng ta có thể duy trì một <code>std::set</code> tại mỗi nút chứa các giá trị. Khi DFS quay lại từ con lên cha, chúng ta hợp nhất tập hợp của con vào cha. Để đảm bảo độ phức tạp \(O(n \log^2 n)\), chúng ta luôn hợp nhất tập hợp nhỏ hơn vào tập hợp lớn hơn.
    </p>

    <h3>Cài đặt</h3>

<pre><code><span class="cpp-keyword">void</span> <span class="cpp-func">dfs</span>(<span class="cpp-keyword">int</span> s, <span class="cpp-keyword">int</span> e) {
    <span class="cpp-comment">// Mỗi nút bắt đầu với 1 tập hợp chứa giá trị của nó</span>
    sets[s] = <span class="cpp-keyword">new</span> set&lt;<span class="cpp-keyword">int</span>&gt;;
    sets[s]-&gt;insert(val[s]);

    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">auto</span> u : adj[s]) {
        <span class="cpp-keyword">if</span> (u == e) <span class="cpp-keyword">continue</span>;
        <span class="cpp-func">dfs</span>(u, s);
        
        <span class="cpp-comment">// Kỹ thuật Small-to-Large: Hợp nhất set nhỏ vào set lớn</span>
        <span class="cpp-keyword">if</span> (sets[s]-&gt;size() &lt; sets[u]-&gt;size()) {
            swap(sets[s], sets[u]); <span class="cpp-comment">// Hoán đổi con trỏ, O(1)</span>
        }
        <span class="cpp-comment">// Chèn phần tử từ set con vào set cha</span>
        <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> x : *sets[u]) {
            sets[s]-&gt;insert(x);
        }
    }
    <span class="cpp-comment">// answer[s] = sets[s]->size(); // Lưu kết quả</span>
}</code></pre>

</body>
</html>