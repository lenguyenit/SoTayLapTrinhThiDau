<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPH - Chương 27: Các thuật toán căn bậc hai</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 { margin-top: 40px; }
        p { margin-bottom: 15px; text-align: justify; }
        
        /* Code styling */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f1f3f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d63384;
        }
        
        /* Syntax highlighting */
        .cpp-keyword { color: #0000ff; font-weight: bold; }
        .cpp-type { color: #2b91af; }
        .cpp-number { color: #098658; }
        .cpp-func { color: #795e26; }
        .cpp-comment { color: #008000; font-style: italic; }
        .cpp-struct { color: #267f99; font-weight: bold; }

        /* Graphics Containers */
        .graphic-box {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        /* SVG Styling */
        svg text { font-family: "Segoe UI", sans-serif; font-size: 14px; text-anchor: middle; dominant-baseline: central; font-weight: bold; }
        .block-bg { fill: #e3f2fd; stroke: #2196f3; stroke-width: 1; stroke-dasharray: 4; }
        .cell-rect { fill: #fff; stroke: #333; stroke-width: 1; }
        .highlight-rect { fill: #fff9c4; stroke: #fbc02d; stroke-width: 2; }
        .summary-rect { fill: #e8f5e9; stroke: #2e7d32; stroke-width: 2; }
        .query-line { stroke: #d35400; stroke-width: 3; marker-end: url(#arrowSQ); }
        .arrow-head { fill: #d35400; }

        /* TOC */
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc a { text-decoration: none; color: #007bff; font-weight: 500; }
    </style>
</head>
<body>

    <div class="toc">
        <h3>Mục lục - Chương 27</h3>
        <ul>
            <li><a href="#intro">Các thuật toán căn bậc hai</a></li>
            <li><a href="#sec27.1">27.1 Phân rã căn</a></li>
            <li><a href="#sec27.2">27.2 Thuật toán Mo</a></li>
            <li><a href="#sec27.3">27.3 Các tối ưu khác</a></li>
        </ul>
    </div>

    <h1 id="intro">Chương 27: Các thuật toán căn bậc hai (Square root algorithms)</h1>
    <p>
        Các thuật toán căn bậc hai là một nhóm các kỹ thuật tối ưu hóa dựa trên ý tưởng chia dữ liệu thành các khối có kích thước \(\sqrt{n}\). Trong nhiều trường hợp, điều này cho phép chúng ta thực hiện các thao tác với độ phức tạp \(O(\sqrt{n})\), nhanh hơn \(O(n)\) nhưng chậm hơn \(O(\log n)\).
    </p>
    <p>
        Mặc dù độ phức tạp không tốt bằng cấu trúc cây (như Segment Tree), nhưng thuật toán căn bậc hai thường linh hoạt hơn, dễ cài đặt hơn và có thể giải quyết một số bài toán mà cây không làm được.
    </p>

    <h2 id="sec27.1">27.1 Phân rã căn (Square root decomposition)</h2>
    <p>
        Kỹ thuật này chia mảng gồm \(n\) phần tử thành các khối (blocks), mỗi khối có kích thước khoảng \(\sqrt{n}\).
        Với mỗi khối, chúng ta duy trì thông tin tổng hợp (ví dụ: tổng, giá trị lớn nhất, v.v.).
    </p>
    <p>
        Ví dụ: Cho mảng 16 phần tử. Kích thước khối là \(\sqrt{16} = 4\). Chúng ta có 4 khối.
        Mảng: <code>[5, 8, 6, 3, 2, 7, 2, 6, 7, 1, 7, 5, 6, 2, 3, 2]</code>
        Khối: <code>[Sum=22]</code>, <code>[Sum=17]</code>, <code>[Sum=20]</code>, <code>[Sum=13]</code>
    </p>

    <div class="graphic-box">
        <svg width="500" height="200" viewBox="0 0 500 200">
            <g transform="translate(20, 50)">
                <rect x="0" y="-10" width="100" height="60" class="block-bg"/>
                <rect x="110" y="-10" width="100" height="60" class="block-bg"/>
                <rect x="220" y="-10" width="100" height="60" class="block-bg"/>
                <rect x="330" y="-10" width="100" height="60" class="block-bg"/>
            </g>

            <g transform="translate(20, 50)">
                <rect x="0" y="0" width="25" height="40" class="cell-rect"/> <text x="12.5" y="25">5</text>
                <rect x="25" y="0" width="25" height="40" class="cell-rect"/> <text x="37.5" y="25">8</text>
                <rect x="50" y="0" width="25" height="40" class="highlight-rect"/> <text x="62.5" y="25">6</text> <rect x="75" y="0" width="25" height="40" class="highlight-rect"/> <text x="87.5" y="25">3</text>

                <rect x="110" y="0" width="25" height="40" class="highlight-rect"/> <text x="122.5" y="25">2</text>
                <rect x="135" y="0" width="25" height="40" class="highlight-rect"/> <text x="147.5" y="25">7</text>
                <rect x="160" y="0" width="25" height="40" class="highlight-rect"/> <text x="172.5" y="25">2</text>
                <rect x="185" y="0" width="25" height="40" class="highlight-rect"/> <text x="197.5" y="25">6</text>

                <rect x="220" y="0" width="25" height="40" class="highlight-rect"/> <text x="232.5" y="25">7</text>
                <rect x="245" y="0" width="25" height="40" class="cell-rect"/> <text x="257.5" y="25">1</text>
                <rect x="270" y="0" width="25" height="40" class="cell-rect"/> <text x="282.5" y="25">7</text>
                <rect x="295" y="0" width="25" height="40" class="cell-rect"/> <text x="307.5" y="25">5</text>
                
                </g>

            <g transform="translate(20, 110)">
                <rect x="0" y="0" width="100" height="30" class="summary-rect"/> <text x="50" y="20" fill="#2e7d32">S=22</text>
                <rect x="110" y="0" width="100" height="30" class="summary-rect"/> <text x="160" y="20" fill="#2e7d32">S=17</text>
                <rect x="220" y="0" width="100" height="30" class="summary-rect"/> <text x="270" y="20" fill="#2e7d32">S=20</text>
                <rect x="330" y="0" width="100" height="30" class="summary-rect"/> <text x="380" y="20" fill="#2e7d32">S=13</text>
            </g>
            
            <text x="250" y="160" font-size="13" fill="#555">Truy vấn [2, 8]: Tính riêng lẻ (6+3) + Khối đầy (17) + Tính riêng lẻ (7)</text>
        </svg>
    </div>

    <h3>Xử lý truy vấn</h3>
    <p>Để tính tổng trong đoạn \([L, R]\), ta chia đoạn thành ba phần:</p>
    <ol>
        <li>Các phần tử đơn lẻ ở đầu đoạn (thuộc khối đầu tiên bị cắt).</li>
        <li>Các khối nằm trọn vẹn ở giữa.</li>
        <li>Các phần tử đơn lẻ ở cuối đoạn (thuộc khối cuối cùng bị cắt).</li>
    </ol>
    <p>Độ phức tạp: Số phần tử đơn lẻ tối đa là \(2\sqrt{n}\), số khối tối đa là \(\sqrt{n}\). Tổng thời gian là \(O(\sqrt{n})\).</p>

    <h3>Cập nhật</h3>
    <p>Khi cập nhật giá trị \(A[i]\), ta chỉ cần cập nhật giá trị tổng của khối chứa \(i\). Thời gian \(O(1)\).</p>

    <h3>Cài đặt</h3>
<pre><code><span class="cpp-keyword">const</span> <span class="cpp-keyword">int</span> LEN = <span class="cpp-number">320</span>; <span class="cpp-comment">// Kích thước khối ~ sqrt(10^5)</span>
<span class="cpp-keyword">int</span> a[N], b[N / LEN + <span class="cpp-number">5</span>]; <span class="cpp-comment">// a: mảng gốc, b: mảng khối</span>

<span class="cpp-keyword">void</span> <span class="cpp-func">update</span>(<span class="cpp-keyword">int</span> idx, <span class="cpp-keyword">int</span> val) {
    <span class="cpp-keyword">int</span> block_idx = idx / LEN;
    b[block_idx] -= a[idx];
    a[idx] = val;
    b[block_idx] += a[idx];
}

<span class="cpp-keyword">int</span> <span class="cpp-func">query</span>(<span class="cpp-keyword">int</span> l, <span class="cpp-keyword">int</span> r) {
    <span class="cpp-keyword">int</span> sum = <span class="cpp-number">0</span>;
    <span class="cpp-keyword">int</span> bl = l / LEN, br = r / LEN;

    <span class="cpp-keyword">if</span> (bl == br) {
        <span class="cpp-comment">// Cùng một khối</span>
        <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = l; i &lt;= r; i++) sum += a[i];
    } <span class="cpp-keyword">else</span> {
        <span class="cpp-comment">// Phần đầu</span>
        <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = l; i &lt; (bl + <span class="cpp-number">1</span>) * LEN; i++) sum += a[i];
        <span class="cpp-comment">// Các khối ở giữa</span>
        <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = bl + <span class="cpp-number">1</span>; i &lt; br; i++) sum += b[i];
        <span class="cpp-comment">// Phần cuối</span>
        <span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = br * LEN; i &lt;= r; i++) sum += a[i];
    }
    <span class="cpp-keyword">return</span> sum;
}</code></pre>

    <h2 id="sec27.2">27.2 Thuật toán Mo (Mo's Algorithm)</h2>
    <p>
        Thuật toán Mo là một kỹ thuật để trả lời các truy vấn đoạn <strong>offline</strong> (biết trước tất cả các truy vấn). Nó dựa trên việc sắp xếp lại thứ tự xử lý các truy vấn để tối ưu hóa việc di chuyển con trỏ.
    </p>
    <p>
        Giả sử chúng ta duy trì một đoạn hiện tại \([curL, curR]\) và cần chuyển sang truy vấn tiếp theo \([L, R]\). Chi phí di chuyển là \(|curL - L| + |curR - R|\).
    </p>
    
    <h3>Thứ tự sắp xếp</h3>
    <p>
        Chia mảng thành các khối kích thước \(S = n/\sqrt{q}\) (thường lấy \(\sqrt{n}\)).
        Sắp xếp các truy vấn theo quy tắc:
    </p>
    <ul>
        <li>Theo chỉ số khối của đầu mút trái \(L / S\).</li>
        <li>Nếu cùng khối \(L\), sắp xếp theo \(R\). (Có thể tối ưu bằng cách sắp xếp \(R\) tăng dần cho khối chẵn và giảm dần cho khối lẻ để đường đi con trỏ R theo hình zíc-zắc).</li>
    </ul>
    <p>Độ phức tạp tổng quát: \(O((n+q)\sqrt{n})\).</p>

    <div class="graphic-box">
        <svg width="400" height="200" viewBox="0 0 400 200">
            <defs>
                <marker id="arrowMo" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                    <path d="M0,0 L0,6 L9,3 z" fill="#d35400" />
                </marker>
            </defs>

            <line x1="40" y1="180" x2="360" y2="180" stroke="#333"/> <line x1="40" y1="180" x2="40" y2="20" stroke="#333"/> <text x="350" y="195" font-size="12">L</text>
            <text x="20" y="30" font-size="12">R</text>

            <line x1="120" y1="180" x2="120" y2="20" stroke="#eee" stroke-dasharray="4"/>
            <line x1="200" y1="180" x2="200" y2="20" stroke="#eee" stroke-dasharray="4"/>
            <line x1="280" y1="180" x2="280" y2="20" stroke="#eee" stroke-dasharray="4"/>

            <circle cx="60" cy="140" r="4" fill="#d35400"/>
            <circle cx="70" cy="100" r="4" fill="#d35400"/>
            <circle cx="80" cy="60" r="4" fill="#d35400"/>
            <path d="M60,140 L70,100 L80,60" fill="none" stroke="#d35400" stroke-width="2"/>

            <circle cx="140" cy="50" r="4" fill="#2980b9"/>
            <circle cx="150" cy="110" r="4" fill="#2980b9"/>
            <path d="M80,60 L140,50 L150,110" fill="none" stroke="#999" stroke-width="1" stroke-dasharray="4"/>
            <path d="M140,50 L150,110" fill="none" stroke="#2980b9" stroke-width="2"/>

            <text x="80" y="195" font-size="10">Block 1</text>
            <text x="160" y="195" font-size="10">Block 2</text>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 27.2: Đường đi của con trỏ trong thuật toán Mo (R tăng trong khối)</div>
    </div>

    <h3>Cài đặt</h3>
    <p>Ví dụ bài toán: Đếm số phần tử phân biệt trong đoạn.</p>

<pre><code><span class="cpp-keyword">int</span> BLOCK_SIZE;
<span class="cpp-keyword">struct</span> <span class="cpp-struct">Query</span> {
    <span class="cpp-keyword">int</span> l, r, id;
    <span class="cpp-keyword">bool</span> <span class="cpp-keyword">operator</span>&lt;(<span class="cpp-keyword">const</span> Query& other) <span class="cpp-keyword">const</span> {
        <span class="cpp-keyword">if</span> (l / BLOCK_SIZE != other.l / BLOCK_SIZE)
            <span class="cpp-keyword">return</span> l / BLOCK_SIZE &lt; other.l / BLOCK_SIZE;
        <span class="cpp-comment">// Tối ưu: Nếu khối lẻ thì R tăng, khối chẵn thì R giảm</span>
        <span class="cpp-keyword">return</span> ((l / BLOCK_SIZE) & <span class="cpp-number">1</span>) ? (r &lt; other.r) : (r &gt; other.r);
    }
};

<span class="cpp-keyword">int</span> cnt[MAX_VAL], current_answer = <span class="cpp-number">0</span>;
<span class="cpp-keyword">int</span> answers[MAX_Q];

<span class="cpp-keyword">void</span> <span class="cpp-func">add</span>(<span class="cpp-keyword">int</span> pos) {
    cnt[a[pos]]++;
    <span class="cpp-keyword">if</span> (cnt[a[pos]] == <span class="cpp-number">1</span>) current_answer++;
}

<span class="cpp-keyword">void</span> <span class="cpp-func">remove</span>(<span class="cpp-keyword">int</span> pos) {
    cnt[a[pos]]--;
    <span class="cpp-keyword">if</span> (cnt[a[pos]] == <span class="cpp-number">0</span>) current_answer--;
}

<span class="cpp-comment">// Trong hàm main:</span>
<span class="cpp-comment">// BLOCK_SIZE = n / sqrt(q);</span>
<span class="cpp-comment">// sort(queries.begin(), queries.end());</span>
<span class="cpp-keyword">int</span> cur_l = <span class="cpp-number">0</span>, cur_r = <span class="cpp-number">-1</span>;
<span class="cpp-keyword">for</span> (<span class="cpp-keyword">const</span> <span class="cpp-keyword">auto</span>& q : queries) {
    <span class="cpp-keyword">while</span> (cur_l &gt; q.l) <span class="cpp-func">add</span>(--cur_l);
    <span class="cpp-keyword">while</span> (cur_r &lt; q.r) <span class="cpp-func">add</span>(++cur_r);
    <span class="cpp-keyword">while</span> (cur_l &lt; q.l) <span class="cpp-func">remove</span>(cur_l++);
    <span class="cpp-keyword">while</span> (cur_r &gt; q.r) <span class="cpp-func">remove</span>(cur_r--);
    answers[q.id] = current_answer;
}</code></pre>

    <h2 id="sec27.3">27.3 Các tối ưu khác</h2>
    <p>
        Kỹ thuật căn bậc hai còn có thể áp dụng trong các tình huống khác:
    </p>
    <ul>
        <li><strong>Gộp bộ đệm (Batch processing):</strong> Nếu chúng ta có hai loại thao tác (nhẹ và nặng), chúng ta có thể gộp \(\sqrt{n}\) thao tác nhẹ lại để xử lý một lần cùng thao tác nặng (ví dụ: xây dựng lại cấu trúc dữ liệu).</li>
        <li><strong>Chia tách tập hợp (Heavy-Light decomposition):</strong> Trong đồ thị, các nút có bậc lớn hơn \(\sqrt{E}\) được gọi là "nút nặng", còn lại là "nút nhẹ". Số lượng nút nặng không quá \(\sqrt{E}\). Ta có thể xử lý riêng biệt hai loại này để tối ưu.</li>
    </ul>

</body>
</html>