<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPH - Chương 15: Cây khung</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h1 { margin-top: 40px; }
        p { margin-bottom: 15px; text-align: justify; }
        
        /* Code styling */
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f1f3f5;
            padding: 2px 4px;
            border-radius: 3px;
            color: #d63384;
        }
        
        /* Syntax highlighting */
        .cpp-keyword { color: #0000ff; font-weight: bold; }
        .cpp-type { color: #2b91af; }
        .cpp-number { color: #098658; }
        .cpp-func { color: #795e26; }
        .cpp-comment { color: #008000; font-style: italic; }
        .cpp-struct { color: #267f99; font-weight: bold; }

        /* Graphic Boxes */
        .graphic-box {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        /* SVG Styling */
        svg text { font-family: "Segoe UI", sans-serif; font-size: 14px; text-anchor: middle; dominant-baseline: central; font-weight: bold; }
        .node-circle { fill: #fff; stroke: #2c3e50; stroke-width: 2; }
        .edge-line { stroke: #999; stroke-width: 1.5; }
        .edge-mst { stroke: #e65100; stroke-width: 3; }
        .edge-weight-bg { fill: #fff; stroke: #fff; stroke-width: 3px; }
        .edge-weight-text { fill: #333; font-size: 12px; font-weight: bold; }

        /* TOC */
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc a { text-decoration: none; color: #007bff; font-weight: 500; }
    </style>
</head>
<body>

    <div class="toc">
        <h3>Mục lục - Chương 15</h3>
        <ul>
            <li><a href="#intro">Cây khung</a></li>
            <li><a href="#sec15.1">15.1 Thuật toán Kruskal</a></li>
            <li><a href="#sec15.2">15.2 Cấu trúc Union-Find</a></li>
            <li><a href="#sec15.3">15.3 Thuật toán Prim</a></li>
        </ul>
    </div>

    <h1 id="intro">Chương 15: Cây khung (Spanning trees)</h1>
    <p>
        Một <strong>cây khung</strong> (spanning tree) của một đồ thị là một đồ thị con bao gồm tất cả các nút của đồ thị gốc và chứa một tập hợp các cạnh kết nối tất cả các nút mà không tạo thành chu trình. Nói cách khác, nó là một cái cây bao trùm tất cả các nút.
    </p>
    <p>
        Một đồ thị có thể có nhiều cây khung khác nhau. Trong đồ thị có trọng số, chúng ta thường quan tâm đến việc tìm <strong>cây khung nhỏ nhất</strong> (minimum spanning tree - MST). Đây là cây khung mà tổng trọng số các cạnh là nhỏ nhất có thể.
    </p>
    <p>
        Ví dụ, xem xét đồ thị sau:
    </p>

    <div class="graphic-box">
        <svg width="400" height="220" viewBox="0 0 400 220">
            <g id="mst-edges">
                <line x1="50" y1="110" x2="150" y2="50" class="edge-mst"/>
                <line x1="150" y1="50" x2="250" y2="50" class="edge-mst"/>
                <line x1="50" y1="110" x2="150" y2="170" class="edge-mst"/>
                <line x1="250" y1="50" x2="350" y2="110" class="edge-mst"/>
                <line x1="150" y1="170" x2="250" y2="170" class="edge-mst"/>
                
                <line x1="150" y1="50" x2="150" y2="170" class="edge-line"/>
                <line x1="250" y1="50" x2="250" y2="170" class="edge-line"/>
                <line x1="150" y1="170" x2="350" y2="110" class="edge-line"/>
                <line x1="250" y1="170" x2="350" y2="110" class="edge-line"/>
            </g>

            <g id="mst-weights">
                <rect x="90" y="70" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="90" y="70" class="edge-weight-text">3</text>
                <rect x="200" y="50" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="200" y="50" class="edge-weight-text">5</text>
                <rect x="90" y="150" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="90" y="150" class="edge-weight-text">6</text>
                <rect x="150" y="110" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="150" y="110" class="edge-weight-text" fill="#999">8</text>
                <rect x="250" y="110" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="250" y="110" class="edge-weight-text" fill="#999">7</text>
                <rect x="310" y="70" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="310" y="70" class="edge-weight-text">9</text>
                <rect x="200" y="170" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="200" y="170" class="edge-weight-text">3</text>
                <rect x="250" y="140" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="250" y="140" class="edge-weight-text" fill="#999">10</text>
                <rect x="310" y="150" width="20" height="20" class="edge-weight-bg" transform="translate(-10,-10)"/> <text x="310" y="150" class="edge-weight-text" fill="#999">12</text>
            </g>

            <g id="mst-nodes">
                <circle cx="50" cy="110" r="18" class="node-circle"/> <text x="50" y="110">1</text>
                <circle cx="150" cy="50" r="18" class="node-circle"/> <text x="150" y="50">2</text>
                <circle cx="250" cy="50" r="18" class="node-circle"/> <text x="250" y="50">3</text>
                <circle cx="150" cy="170" r="18" class="node-circle"/> <text x="150" y="170">4</text>
                <circle cx="250" cy="170" r="18" class="node-circle"/> <text x="250" y="170">5</text>
                <circle cx="350" cy="110" r="18" class="node-circle"/> <text x="350" y="110">6</text>
            </g>
        </svg>
        <div style="font-style: italic; margin-top: 5px;">Hình 15.1: Cây khung nhỏ nhất (các cạnh đậm màu cam). Trọng số: 26.</div>
    </div>

    <h2 id="sec15.1">15.1 Thuật toán Kruskal</h2>
    <p>
        Thuật toán Kruskal ban đầu có \(n\) thành phần liên thông, mỗi thành phần bao gồm một nút duy nhất. Thuật toán duyệt qua các cạnh của đồ thị theo thứ tự trọng số tăng dần. Đối với mỗi cạnh, nếu hai đầu mút của nó thuộc về hai thành phần khác nhau, thuật toán sẽ thêm cạnh đó vào cây và hợp nhất hai thành phần. Ngược lại, nếu các đầu mút đã thuộc cùng một thành phần, cạnh sẽ bị bỏ qua.
    </p>

    <h3>Cài đặt</h3>
    <p>
        Khi cài đặt thuật toán Kruskal, danh sách cạnh là cấu trúc dữ liệu thuận tiện nhất. Cạnh cần bao gồm trọng số để có thể sắp xếp. Chúng ta có thể định nghĩa một cấu trúc cạnh và toán tử so sánh như sau:
    </p>

<pre><code><span class="cpp-keyword">struct</span> <span class="cpp-struct">Edge</span> {
    <span class="cpp-keyword">int</span> u, v, w;
    <span class="cpp-keyword">bool</span> <span class="cpp-keyword">operator</span>&lt;(<span class="cpp-struct">Edge</span> <span class="cpp-keyword">const</span>& other) {
        <span class="cpp-keyword">return</span> w &lt; other.w;
    }
};</code></pre>

    <p>
        Vòng lặp chính của thuật toán sắp xếp các cạnh và xử lý chúng từng cái một. Hàm <code>unite</code> và <code>same</code> thuộc về cấu trúc dữ liệu Union-Find (sẽ được thảo luận ở phần sau).
    </p>

<pre><code><span class="cpp-type">vector</span>&lt;<span class="cpp-struct">Edge</span>&gt; edges;
...
sort(edges.begin(), edges.end());

<span class="cpp-keyword">for</span> (<span class="cpp-struct">Edge</span> e : edges) {
    <span class="cpp-keyword">if</span> (!same(e.u, e.v)) {
        unite(e.u, e.v);
        <span class="cpp-comment">// thêm cạnh e vào cây</span>
    }
}</code></pre>

    <h2 id="sec15.2">15.2 Cấu trúc Union-Find</h2>
    <p>
        Để cài đặt thuật toán Kruskal hiệu quả, chúng ta cần một cấu trúc dữ liệu quản lý các thành phần liên thông. Cấu trúc <strong>Union-Find</strong> (hay Disjoint Set Union - DSU) hỗ trợ hai thao tác:
    </p>
    <ul>
        <li><code>find(x)</code>: trả về định danh (người đại diện) của thành phần chứa nút \(x\).</li>
        <li><code>unite(a, b)</code>: hợp nhất thành phần chứa \(a\) và thành phần chứa \(b\).</li>
    </ul>
    <p>
        Hàm <code>same</code> trong thuật toán Kruskal có thể được cài đặt bằng cách kiểm tra <code>find(a) == find(b)</code>.
    </p>
    <p>
        Cấu trúc được cài đặt bằng các mảng <code>link</code> và <code>size</code>. Hàm <code>find</code> trả về gốc của cây đại diện cho thành phần (sử dụng nén đường đi), và hàm <code>unite</code> nối cây nhỏ hơn vào cây lớn hơn.
    </p>

<pre><code><span class="cpp-keyword">int</span> link[N], size[N];

<span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) link[i] = i;
<span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) size[i] = <span class="cpp-number">1</span>;

<span class="cpp-keyword">int</span> <span class="cpp-func">find</span>(<span class="cpp-keyword">int</span> x) {
    <span class="cpp-keyword">while</span> (x != link[x]) x = link[x];
    <span class="cpp-keyword">return</span> x;
}

<span class="cpp-keyword">bool</span> <span class="cpp-func">same</span>(<span class="cpp-keyword">int</span> a, <span class="cpp-keyword">int</span> b) {
    <span class="cpp-keyword">return</span> <span class="cpp-func">find</span>(a) == <span class="cpp-func">find</span>(b);
}

<span class="cpp-keyword">void</span> <span class="cpp-func">unite</span>(<span class="cpp-keyword">int</span> a, <span class="cpp-keyword">int</span> b) {
    a = <span class="cpp-func">find</span>(a);
    b = <span class="cpp-func">find</span>(b);
    <span class="cpp-keyword">if</span> (size[a] &lt; size[b]) swap(a, b);
    size[a] += size[b];
    link[b] = a;
}</code></pre>

    <p>
        Độ phức tạp thời gian của thuật toán Kruskal sau khi sắp xếp là \(O(m \log m)\) (hoặc \(O(m \alpha(n))\) nếu dùng DSU tối ưu, nhưng phần sắp xếp chiếm ưu thế).
    </p>

    <h2 id="sec15.3">15.3 Thuật toán Prim</h2>
    <p>
        Thuật toán Prim là một phương pháp khác để tìm cây khung nhỏ nhất. Thuật toán bắt đầu từ một nút tùy ý và phát triển cây bằng cách thêm các cạnh. Tại mỗi bước, thuật toán thêm một cạnh có trọng số nhỏ nhất kết nối một nút đã có trong cây với một nút chưa có trong cây.
    </p>

    <h3>Cài đặt</h3>
    <p>
        Thuật toán Prim tương tự như thuật toán Dijkstra. Sự khác biệt là trong Dijkstra, khoảng cách đến một nút là tổng trọng số các cạnh từ nút bắt đầu, còn trong Prim, khoảng cách là trọng số của cạnh nhỏ nhất kết nối nút đó với cây.
    </p>
    <p>
        Chúng ta sử dụng hàng đợi ưu tiên <code>q</code> để lưu trữ các cặp <code>(w, u)</code>, nghĩa là có một cạnh trọng số <code>w</code> nối nút <code>u</code> với cây khung hiện tại.
    </p>

<pre><code><span class="cpp-keyword">for</span> (<span class="cpp-keyword">int</span> i = <span class="cpp-number">1</span>; i &lt;= n; i++) visited[i] = <span class="cpp-keyword">false</span>;
<span class="cpp-type">priority_queue</span>&lt;<span class="cpp-type">pair</span>&lt;<span class="cpp-keyword">int</span>,<span class="cpp-keyword">int</span>&gt;, <span class="cpp-type">vector</span>&lt;<span class="cpp-type">pair</span>&lt;<span class="cpp-keyword">int</span>,<span class="cpp-keyword">int</span>&gt;&gt;, <span class="cpp-type">greater</span>&lt;<span class="cpp-type">pair</span>&lt;<span class="cpp-keyword">int</span>,<span class="cpp-keyword">int</span>&gt;&gt;&gt; q;
q.push({<span class="cpp-number">0</span>, <span class="cpp-number">1</span>});

<span class="cpp-keyword">while</span> (!q.empty()) {
    <span class="cpp-keyword">int</span> a = q.top().second;
    <span class="cpp-keyword">int</span> w = q.top().first;
    q.pop();

    <span class="cpp-keyword">if</span> (visited[a]) <span class="cpp-keyword">continue</span>;
    visited[a] = <span class="cpp-keyword">true</span>;
    <span class="cpp-comment">// xử lý cạnh trọng số w nối đến a (ví dụ: cộng vào tổng trọng số MST)</span>

    <span class="cpp-keyword">for</span> (<span class="cpp-keyword">auto</span> u : adj[a]) {
        <span class="cpp-keyword">int</span> b = u.first;
        <span class="cpp-keyword">int</span> weight = u.second;
        <span class="cpp-keyword">if</span> (!visited[b]) {
            q.push({weight, b});
        }
    }
}</code></pre>

    <p>
        Độ phức tạp thời gian của thuật toán Prim là \(O(n + m \log m)\), tương đương với Dijkstra. Trong thực tế, Kruskal thường được ưa chuộng hơn vì nó dễ cài đặt hơn và hoạt động tốt trên đồ thị thưa.
    </p>

    <p>
        Để hiểu rõ hơn về cách các thuật toán này hoạt động trực quan, bạn có thể xem video này:
        <br>
        [Minimum Spanning Tree Algorithms Explanation](https://www.youtube.com/watch?v=4ZlRH0eK-qQ)
    </p>
    <p>
        Video này cung cấp hình ảnh động trực quan về cách thuật toán Kruskal và Prim xây dựng cây khung nhỏ nhất từng bước một, giúp củng cố kiến thức lý thuyết vừa học.
    </p>

</body>
</html>